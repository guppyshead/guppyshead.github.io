<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ReentrantLock加锁和释放锁的过程</title>
      <link href="2021/07/10/ReentrantLock%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/10/ReentrantLock%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>ReentrantLock是Java中一个可重入锁，同一个线程可以多次获取这个锁，只需要在释放的时候再多次解锁即可。其内部使用AQS来进行加锁和解锁。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Sync sync;public ReentrantLock() &#123;    sync &#x3D; new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123;    sync &#x3D; fair ? new FairSync() : new NonfairSync();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock内部有一个Sync类型的变量（Sync继承了AQS类），ReentrantLock主要就是依靠Sync变量来进行加锁和解锁。<br>Sync又分为公平锁和非公平锁。当使用无参构造方法时，生成的时非公平锁；使用有参构造方法时，可以指定是公平锁还是非公平锁。</p><h3 id="AQS加锁的几个相关变量"><a href="#AQS加锁的几个相关变量" class="headerlink" title="AQS加锁的几个相关变量"></a>AQS加锁的几个相关变量</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;持有锁的线程加锁次数private volatile int state;&#x2F;&#x2F;等待队列头节点private transient volatile Node head;&#x2F;&#x2F;等待队列尾节点private transient volatile Node tail;&#x2F;&#x2F;当前占有锁的线程private transient Thread exclusiveOwnerThread;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，持有锁的线程会放在exclusiveOwnerThread中，线程加锁的次数会存在state中，而等待锁的线程则会放在等待队列中，等待队列是个双向队列。为了方便管理，双向链表的头节点是不包含任何线程信息，而尾节点会包含线程信息。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>当需要对ReentrantLock进行加锁时，会调用lock方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void lock() &#123;    sync.lock();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其内部调用了sync的lock方法，对于不同类型的锁，lock方法的处理也不一样</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void lock() &#123;  acquire(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>公平锁的lock方法直接调用了acquire方法，其实现是在AbstractQueuedSynchronizer类中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void acquire(int arg) &#123;  if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，会调用tryAcquire方法尝试获取锁，而公平锁的tryAcquire方法实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final boolean tryAcquire(int acquires) &#123;  &#x2F;&#x2F;获取当前线程  final Thread current &#x3D; Thread.currentThread();  &#x2F;&#x2F;获取state变量  int c &#x3D; getState();  &#x2F;&#x2F;state为0，说明没有线程持有当前锁  if (c &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F;如果当前等待队列中没有元素或者头节点的下一个节点是本线程，则会尝试获取锁，成功后将获取锁的线程改为当前线程    if (!hasQueuedPredecessors() &amp;&amp;      compareAndSetState(0, acquires)) &#123;      setExclusiveOwnerThread(current);      return true;    &#125;  &#125;  &#x2F;&#x2F;如果state不为0，则说明有线程持有锁，需要判断是否是当前线程持有锁，如果是，则将state加上本次加锁次数设为新的state  else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;    int nextc &#x3D; c + acquires;    &#x2F;&#x2F;加锁次数已达上限，抛出异常    if (nextc &lt; 0)        throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;  &#125;  return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程尝试获取锁时，或先获取state，state代表持有锁的线程的加锁次数。如果state为0，并且当前等待队列没有线程，则会尝试通过CAS修改state，修改成功则视为加锁成功；如果state不为0，则要判断当前线程是否持有锁，如果是的话，则修改state。</p><p>如果tryAcquire获取锁失败，则会调用addWaiter方法，将当前线程加入等待队列中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Node addWaiter(Node mode) &#123;  &#x2F;&#x2F;将本线程加入等待节点中  Node node &#x3D; new Node(Thread.currentThread(), mode);  Node pred &#x3D; tail;  if (pred !&#x3D; null) &#123;    &#x2F;&#x2F;如果为节点不为空，则将尾节点设为本节点，这一步可能失败    node.prev &#x3D; pred;    if (compareAndSetTail(pred, node)) &#123;      pred.next &#x3D; node;      return node;    &#125;  &#125;  &#x2F;&#x2F;如果尾节点为空，则要进行初始化  enq(node);  return node;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addWaiter方法会将当前线程加入等待队列的队尾，如果等待队列还未初始化，则会调用enq方法进行初始化；如果将当前线程设为尾节点失败，则会调用enq方法，通过自旋将当前线程设为尾节点。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Node enq(final Node node) &#123;  &#x2F;&#x2F;自旋  for (;;) &#123;    Node t &#x3D; tail;    if (t &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;尾节点为空时，新建头节点，并将尾节点指向头节点      if (compareAndSetHead(new Node()))        tail &#x3D; head;    &#125; else &#123;      &#x2F;&#x2F;尾节点不为空，则说明其他线程已经初始化或者第一次将当前线程设为尾节点失败，再次尝试将当前线程设为尾节点      node.prev &#x3D; t;      if (compareAndSetTail(t, node)) &#123;        t.next &#x3D; node;        return t;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将当前线程加入等待队列后，或调用acquireQueued方法再次尝试获取锁</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final boolean acquireQueued(final Node node, int arg) &#123;    boolean failed &#x3D; true;    try &#123;        boolean interrupted &#x3D; false;        for (;;) &#123;            &#x2F;&#x2F;获取当前节点的前一个节点，如果前一个节点是头节点，则尝试使用tryAcquire方法获取锁，成功则返回。通常是在等待队列中被唤醒后执行本段逻辑获取锁，获取锁后会将当前节点设为头节点(线程信息被清空，waitStatus被保存)            final Node p &#x3D; node.predecessor();            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);                p.next &#x3D; null;                failed &#x3D; false;                return interrupted;            &#125;            &#x2F;&#x2F;挂起当前线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted &#x3D; true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果获取锁失败，则会尝试挂起当前线程，判断是否可以挂起线程调用的是shouldParkAfterFailedAcquire方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static boolean shouldParkAfterFailedAcquire(Node pred,  Node node) &#123;    &#x2F;&#x2F;线程能挂起的条件是前驱节点的状态为SIGNAL    int ws &#x3D; pred.waitStatus;    &#x2F;&#x2F;前驱节点为SIGNAL则挂起    if (ws &#x3D;&#x3D; Node.SIGNAL)        return true;    if (ws &gt; 0) &#123;        &#x2F;&#x2F;前驱节点为CANCELLED，则一直向前找到SIGNAL的节点，设为前驱节点        do &#123;            node.prev &#x3D; pred &#x3D; pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next &#x3D; node;    &#125; else &#123;        &#x2F;&#x2F;前驱节点还未被设置状态，直接通过CAS设为SIGNAL(可能失败)        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    &#x2F;&#x2F;本次执行方法时前驱节点不为SIGNAL，返回false，让acquireQueued进入下一个循环判断是否可以安全挂起    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个节点的waitStatus状态包括以下几个状态</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int CANCELLED &#x3D;  1;static final int SIGNAL    &#x3D; -1;static final int CONDITION &#x3D; -2;static final int PROPAGATE &#x3D; -3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当前驱节点为SIGNAL时，表示本节点可以唤醒下一个节点。如果一个节点可以被挂起，则会调用parkAndCheckInterrupt方法挂起线程</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final boolean parkAndCheckInterrupt() &#123;  LockSupport.park(this);  return Thread.interrupted();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，对于公平锁来说，如果等待队列中没有线程，才会去获取锁；否则会将当前线程加入等待队列中，并将自己挂起。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void lock() &#123;  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁进行加锁时，首先会竞争锁，竞争失败再调用acquire方法。acquire方法和公平锁一样，调用的都是AbstractQueuedSynchronizer的acquire方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void acquire(int arg) &#123;  if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁的tryAcquire方法调用的是nonfairTryAcquire方法，这个方法的实现在Sync类中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final class NonfairSync extends Sync &#123;    private static final long serialVersionUID &#x3D; 7316153563782823691L;    protected final boolean tryAcquire(int acquires) &#123;        return nonfairTryAcquire(acquires);    &#125;&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123;    final boolean nonfairTryAcquire(int acquires) &#123;        final Thread current &#x3D; Thread.currentThread();        int c &#x3D; getState();        if (c &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F;不判断等待队列是否为空，直接竞争锁            if (compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;            int nextc &#x3D; c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁的tryAcquire方法和公平锁的tryAcquire方法大体相同，唯一不同的是非公平锁不管等待队列是否为空都会竞争锁。当进入等待队列后，公平锁和非公平锁几乎相同。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁调用的是ReentrantLock的unlock方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void unlock() &#123;    sync.release(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的release方法实现在AbstractQueuedSynchronizer中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h &#x3D; head;        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用tryRelease方法释放独占线程，其实现在Sync中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final boolean tryRelease(int releases) &#123;    int c &#x3D; getState() - releases;    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free &#x3D; false;    if (c &#x3D;&#x3D; 0) &#123;        free &#x3D; true;        setExclusiveOwnerThread(null);    &#125;    setState(c);    return free;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑也很简单，将state减去被释放的锁次数，如果state为0，则说明锁已经被释放，将当前占有锁的线程置为null。释放锁成功后，release方法会判断头节点是否为空，waitStatus是否不为0(通常来说，当等待队列第一个元素加入的时候，头节点的waitStatus在shouldParkAfterFailedAcquire方法中会被设为SIGNAL)，如果判断通过，会调用unparkSuccessor方法唤醒后续节点</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void unparkSuccessor(Node node) &#123;    int ws &#x3D; node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    Node s &#x3D; node.next;    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;        s &#x3D; null;        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)            if (t.waitStatus &lt;&#x3D; 0)                s &#x3D; t;    &#125;    if (s !&#x3D; null)        LockSupport.unpark(s.thread);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唤醒后续节点时，如果头节点的下一个节点waitStatus&gt;0，则说明该线程已经取消等待，会从队尾遍历到队头，找到第一个waitStatus小于0的节点，将其唤醒并获得锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的volatile关键字</title>
      <link href="2021/07/03/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/07/03/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Java中多线程环境下为了保证共享变量的可见性，通常会使用volatile关键字修饰该变量，但volatile关键字并不只保证可见性。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>不同于计算机的内存模型，JVM构建了一套简化的线程模型<br><img src="https://images2.imgbox.com/b0/05/arz8Brgk_o.jpg" alt="Java内存模型"><br>每条线程都会有自己单独的工作内存用来存储共享数据，每当线程要操作一个共享变量时，会首先将该变量从主内存加载到工作内存中，在工作内存中修改之后再刷回主内存中。所以在每个线程的工作内存中，同一个共享变量有可能有不同的值。</p><h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>被volatile关键字修饰的共享变量，在被线程获取后，会给共享变量加上Lock锁，阻止其他线程对该变量进行读写，在线程把共享变量从工作内存刷回主内存后会释放Lock锁，这时其他线程才可以获取到这个变量，因此volatile可以保证变量的可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在同一条语句中，volatile关键字可以禁止指令重排。在单例模式的double check写法中，如果不给变量加volatile关键字，就有可能出现空指针异常</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SingletonObject &#123;    private static Object object;    public static Object getSingleton()&#123;        &#x2F;&#x2F;A)        if (Objects.isNull(object))&#123;            synchronized (SingletonObject.class)&#123;                if (Objects.isNull(object))&#123;                    &#x2F;&#x2F;B）可能发生指令重排                    object &#x3D; new Object();                &#125;            &#125;        &#125;        return object;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在代码B处，实际有三个指令:1.在堆内存中开辟一块空间给Object，2.将object指向该空间，3.执行Object的init方法。其中第二步和第三步并没有先后顺序，有可能会发生指令重排，先执行第二步，然后执行第三步，在执行第三步之前Objects.isnull(object)返回的是false，因为object已经指向了堆内存中的一块空间,如果其他线程在第二步后执行到代码A处，则会返回一个没有执行init方法的对象，使用这个对象会报空指针异常。<br>但是如果给object变量加上volatile关键字，则能禁止代码B处的指令重排，因此volatile关键字可以保证变量操作的有序性</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static volatile Object object;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>在多线程环境下，一系列的操作要么同时成功，要么同时失败，则可以称这一系列的操作有原子性(不可分割)。volatile明显不能保证这种操作。当然也有例外，在32位操作系统的JVM中，CPU对于long和double类型的变量操作实际是分为两步来进行的，因为CPU一次只能操作32位数据，而long和double类型的变量有64位，此时对变量添加volatile关键字能保证变量操作的原子性。</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>volatile在操作系统底层实际依靠MESI协议来保证变量操作的可见性，MESI代表变量的四种状态</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>M(Modified)</td><td>变量有效，但是已经被修改，和主内存中的数据不一致</td></tr><tr><td>E(Exclusive)</td><td>变量有效，数据只存在本缓存行中，和主内存中的数据一致</td></tr><tr><td>S(Shared)</td><td>变量有效，数据存在很多缓存行中，和主内存中的数据一致</td></tr><tr><td>I(Invalid)</td><td>变量无效</td></tr></tbody></table><p>当多核硬件系统操作数据时，大致流程如下:<br>1.两个CPU通过总线将主内存中的变量a加载到各自的高速缓存中，此时两个CPU中的变量a都是共享(S)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/04e64e2360fb9b2c3826e876c8df6da460a78f75.png"></p><p>2.当CPU1要对a变量进行修改时，会先向总线发送请求，要求对a变量进行修改，总线会通知CUP2，将a变量置为无效(I)；待CPU2将a置为无效后通知总线，总线通知CPU1，CPU1修改a后，将a状态置为已修改(M)<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/adbb81abe53d980adf78cefc83c4d7e39aed357c.png"></p><p>3.CPU1通过总线将a刷回主内存，并将自己缓存区内的a置为独占(E)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/2428bb14748e254e5fc6327de77fa0b6fc07b64f.png"></p><p>4.当CPU2要使用a变量时，发现自己缓存区中的a为无效(I)状态，通过总线从主内存中读取a，此时CPU1和CPU2中的a都变为共享(S)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/04e64e2360fb9b2c3826e876c8df6da460a78f75.png"></p><h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p>当大量被volatile的变量频繁进行修改或者有大量CAS操作频繁进行(也可能两者都有)，总线的流量激增，此时会造成总线风暴，总线的数据处理能力会大大降低。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor源码解析</title>
      <link href="2021/06/26/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/26/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>在服务器中，为了减少频繁创建线程给系统带来的不必要开销，当需要使用线程时，通常会采用线程池的方式。不同系统中的线程池实现方式不同，在JDK1.8中，线程池使用线程+等待队列的方式实现。</p><p>###主要成员变量及其含义</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;ctl中，高三位存储的是线程池当前的状态，低29位存储的是线程池中线程个数(默认为RUNNING状态，线程个数为0，这里说的低29位只适用于Integer最大为2^32的系统)private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));&#x2F;&#x2F;ctl中低多少位用来保存线程数，通常来说是29private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;&#x2F;&#x2F;线程池能容纳的最大线程数，低29位都为1（低多少位为1取决于系统中Integer的最大值）private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;&#x2F;&#x2F;线程池处于运行状态private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于shutdown状态（此时线程池中仍在执行的任务不会被中止，但不接受新任务），调用shutdown方法后由RUNNING变为SHUTDOWNprivate static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于stop状态（此时线程池不接受新任务，清空任务队列，并会尝试中断所有活跃线程），调用shutdownNow方法后由RUNNING或SHUTDOWN变为STOPprivate static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于tidying状态（此时线程池中，活跃线程变为0且任务队列中没有任务），SHUTDOWN或STOP状态下处理完所有任务则变为TIDYINGprivate static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池彻底终止，TIDYING状态下调用terminated方法后变为TERMINATEDprivate static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;计算线程状态private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;&#x2F;&#x2F;计算当前线程池中活跃线程数量private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;&#x2F;&#x2F;计算ctl值private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;&#x2F;&#x2F;线程池所使用的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;&#x2F;&#x2F;线程池中包含所有线程的工作队列private final HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;();&#x2F;&#x2F;核心线程数private volatile int corePoolSize;&#x2F;&#x2F;最大线程数private volatile int maximumPoolSize;&#x2F;&#x2F;线程被回收前最大的闲置时间private volatile long keepAliveTime;&#x2F;&#x2F;拒绝策略private volatile RejectedExecutionHandler handler;&#x2F;&#x2F;创建线程使用的线程工厂private volatile ThreadFactory threadFactory;&#x2F;&#x2F;默认拒绝策略（拒绝任务并抛出异常）private static final RejectedExecutionHandler defaultHandler &#x3D;        new AbortPolicy();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) &#123;    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;&#x3D; 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)        throw new NullPointerException();    this.corePoolSize &#x3D; corePoolSize;    this.maximumPoolSize &#x3D; maximumPoolSize;    this.workQueue &#x3D; workQueue;    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);    this.threadFactory &#x3D; threadFactory;    this.handler &#x3D; handler;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的构造函数都会指向这个构造方法，这个构造方法的入参含义依次为核心线程数，最大线程数，空闲时间，空闲时间单位，阻塞队列，线程工厂，拒绝策略</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>提交任务通常使用submit方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Future&lt;?&gt; submit(Runnable task) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);  execute(ftask);  return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);  execute(ftask);  return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);  execute(ftask);  return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;  return new FutureTask&lt;T&gt;(callable);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>submit方法中首先将入参包装成FutureTask类，然后执行execute方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void execute(Runnable command) &#123;  if (command &#x3D;&#x3D; null)    throw new NullPointerException();  int c &#x3D; ctl.get();  if (workerCountOf(c) &lt; corePoolSize) &#123;    if (addWorker(command, true))      return;    c &#x3D; ctl.get();  &#125;  if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;    int recheck &#x3D; ctl.get();    if (! isRunning(recheck) &amp;&amp; remove(command))      reject(command);    else if (workerCountOf(recheck) &#x3D;&#x3D; 0)      addWorker(null, false);  &#125;  else if (!addWorker(command, false))    reject(command);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>execute方法的逻辑分为三步：</p><ol><li>判断工作线程数是否大于核心线程数，如果小于，则尝试新开一个线程执行该任务(不保证添加线程成功)</li><li>如果工作线程数大于核心线程数并且线程池处于运行状态，则将任务加入阻塞队列中，之后继续判断线程是否处于运行状态，如果不处于运行状态，则尝试移除该任务，移除任务成功则根据拒绝策略执行拒绝逻辑；移除任务失败，则判断工作线程是否为0，为0的话添加一条非核心线程处理任务。</li><li>如果工作线程数大于核心线程数但线程池不处于运行中状态或者处于运行中状态但队列已满，则尝试添加线程执行该任务，如果失败，则执行决绝策略。（非核心线程就是在这一步加入线程池中的）</li></ol><p>实际添加线程的逻辑在addWorker方法中，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private boolean addWorker(Runnable firstTask, boolean core) &#123;      retry:      for (;;) &#123;          int c &#x3D; ctl.get();          &#x2F;&#x2F;获取线程池当前状态          int rs &#x3D; runStateOf(c);          &#x2F;&#x2F;如果线程池处于SHUTDOWN之后的状态或者处于SHUTDOWN状态，但想新建线程，则直接返回false          if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;              ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;                 firstTask &#x3D;&#x3D; null &amp;&amp;                 ! workQueue.isEmpty()))              return false;          &#x2F;&#x2F;自旋，直到更改ctl中的线程数成功；如果自旋过程中发现线程池已达最大容量，则返回false          for (;;) &#123;              int wc &#x3D; workerCountOf(c);              if (wc &gt;&#x3D; CAPACITY ||                  wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))                  return false;              if (compareAndIncrementWorkerCount(c))                  break retry;              c &#x3D; ctl.get();              if (runStateOf(c) !&#x3D; rs)                  continue retry;          &#125;      &#125;      boolean workerStarted &#x3D; false;      boolean workerAdded &#x3D; false;      Worker w &#x3D; null;      try &#123;          &#x2F;&#x2F;新建worker          w &#x3D; new Worker(firstTask);          final Thread t &#x3D; w.thread;          if (t !&#x3D; null) &#123;              &#x2F;&#x2F;新增worker时加锁              final ReentrantLock mainLock &#x3D; this.mainLock;              mainLock.lock();              try &#123;                  int rs &#x3D; runStateOf(ctl.get());                  &#x2F;&#x2F;再次检查线程池状态，如果状态不对则抛出异常，进入finally解锁                  if (rs &lt; SHUTDOWN ||                      (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;                      if (t.isAlive())                          throw new IllegalThreadStateException();                      &#x2F;&#x2F;添加任务                      workers.add(w);                      int s &#x3D; workers.size();                      if (s &gt; largestPoolSize)                          largestPoolSize &#x3D; s;                      workerAdded &#x3D; true;                  &#125;              &#125; finally &#123;                  mainLock.unlock();              &#125;              &#x2F;&#x2F;添加worker成功以后，调用start方法启动worker              if (workerAdded) &#123;                  t.start();                  workerStarted &#x3D; true;              &#125;          &#125;      &#125; finally &#123;          &#x2F;&#x2F;添加任务失败          if (! workerStarted)              addWorkerFailed(w);      &#125;      return workerStarted;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在线程池中，实际执行任务调用的是Worker类，Worker类继承了AQS，并实现了Runnable接口，其构造方法为:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Worker(Runnable firstTask) &#123;  setState(-1);  this.firstTask &#x3D; firstTask;  this.thread &#x3D; getThreadFactory().newThread(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker是个不可重入的锁，并且Worker的Thread调用start方法时，执行的任务为自己，Worker的run方法如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void run() &#123;  runWorker(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中runWorker方法为ThreadPoolExecutor的方法，其实现为:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void runWorker(Worker w) &#123;    Thread wt &#x3D; Thread.currentThread();    Runnable task &#x3D; w.firstTask;    w.firstTask &#x3D; null;    &#x2F;&#x2F;首先对worker解锁，因为刚构造worker时，worker的state为-1    w.unlock();    boolean completedAbruptly &#x3D; true;    try &#123;        &#x2F;&#x2F;循环获取任务        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;            &#x2F;&#x2F;获取任务成功则对worker进行加锁，确保worker同时只会执行一个任务            w.lock();            &#x2F;&#x2F;处于STOP状态时，需要worker中的线程打上中止标，但不会影响线程正在执行的任务            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try &#123;                &#x2F;&#x2F;空实现，可继承ThreadPoolExecutor并重写该方法，在任务执行前对线程和任务进行处理                beforeExecute(wt, task);                Throwable thrown &#x3D; null;                try &#123;                    &#x2F;&#x2F;直接调用run方法                    task.run();                &#125; catch (RuntimeException x) &#123;                    thrown &#x3D; x; throw x;                &#125; catch (Error x) &#123;                    thrown &#x3D; x; throw x;                &#125; catch (Throwable x) &#123;                    thrown &#x3D; x; throw new Error(x);                &#125; finally &#123;                    &#x2F;&#x2F;空实现，可继承ThreadPoolExecutor并重写该方法，在任务执行后对线程和任务进行处理                    afterExecute(task, thrown);                &#125;            &#125; finally &#123;                &#x2F;&#x2F;执行完一次任务后，解锁worker                task &#x3D; null;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly &#x3D; false;    &#125; finally &#123;        &#x2F;&#x2F;当Worker执行完所有任务，并且取不到新的任务时，调用该方法        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>runWorker方法的逻辑非常简单，首先获取任务（新建时自带任务或者从阻塞队列中获取），获取成功则执行任务。从阻塞队列中获取任务时，调用的时getTask方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Runnable getTask() &#123;  boolean timedOut &#x3D; false;  &#x2F;&#x2F;自旋获取任务  for (;;) &#123;      int c &#x3D; ctl.get();      int rs &#x3D; runStateOf(c);      &#x2F;&#x2F;判断线程池状态是否正确，不正确则返回null      if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;          decrementWorkerCount();          return null;      &#125;      int wc &#x3D; workerCountOf(c);      &#x2F;&#x2F;判断阻塞队列取任务时是否进行超时判断      boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;      &#x2F;&#x2F;如果线程池已达最大容量或者非核心线程获取任务超时，并且工作线程不为空阻塞队列为空，则返回null      if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))          &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;          if (compareAndDecrementWorkerCount(c))              return null;          continue;      &#125;      try &#123;          &#x2F;&#x2F;如果线程数小于核心线程数，则使用take方法阻塞核心线程；否则调用poll方法，并设置超时时间，如果过了超时时间还没有取到任务，则返回          Runnable r &#x3D; timed ?              workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :              workQueue.take();          if (r !&#x3D; null)              return r;          timedOut &#x3D; true;      &#125; catch (InterruptedException retry) &#123;          timedOut &#x3D; false;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，对于非核心线程，如果在有效存活时间内取不到任务，则会直接返回null，导致runWorker中跳出循环，并销毁线程。</p><p>从上面的代码可以看出，当向线程池submit一个任务时，会优先添加核心线程处理任务，如果核心线程已满，则优先加入阻塞队列中，如果阻塞队列也放不下，则会新建线程（带超时时间）处理任务；如果到达线程池最大线程数，则会执行拒绝策略。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池有四种拒绝策略：</p><ol><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常</li><li>DiscardPolicy：丢弃提交的任务，并且不抛出异常</li><li>DiscardOldestPolicy：丢弃阻塞队列中头部的任务，重新提交被拒绝的任务</li><li>CallerRunsPolicy：由调用线程执行任务</li></ol><h3 id="tomcat线程池"><a href="#tomcat线程池" class="headerlink" title="tomcat线程池"></a>tomcat线程池</h3><p>tomcat线程池的核心类为StandardThreadExecutor，其内部构造了一个org.apache.tomcat.util.threads.ThreadPoolExecutor类（继承自JDK的ThreadPoolExecutor），并且使用了tomcat自定义的任务队列TaskQueue。<br>在TaskQueue的offer方法中，如果新增任务时，无空闲线程并且tomcat的线程数小于最大线程数，则会返回false</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public boolean offer(Runnable o) &#123;    if (parent&#x3D;&#x3D;null) return super.offer(o);    if (parent.getPoolSize() &#x3D;&#x3D; parent.getMaximumPoolSize()) return super.offer(o);    if (parent.getSubmittedCount()&lt;&#x3D;(parent.getPoolSize())) return super.offer(o);    if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) return false;    return super.offer(o);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于org.apache.tomcat.util.threads.ThreadPoolExecutor的execute方法与JDK中的逻辑一样，因此在进行</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (isRunning(c) &amp;&amp; workQueue.offer(command))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>判断时，workQueue.offer会返回false，也就是说，向tomcat中的线程池中添加任务，若核心线程已满，会优先新建非核心线程执行任务，等到达最大线程容量的时候才向等待队列中插入任务。<br>JDK和tomcat的线程池对于核心线程已满的情况下，新增任务的处理逻辑不同是因为JDK中的线程池处理的任务是CPU密集型任务，对新建线程消耗的资源更敏感；而tomcat作为服务器，处理的大部分是IO密集型任务，对于新建线程消耗的资源没有那么敏感，并且优先新建线程处理任务也能提高服务器的响应能力。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> ThreadPoolExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解析</title>
      <link href="2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>JDK1.8版本的ConcurrentHashMap与JDK1.7采用了不同的实现。不同于JDK1.7中segment+哈希桶数组，JDK1.8使用的数据结构为一个哈希桶数组，同时由于1.8中CAS的支持，在1.8中使用CAS+synchronize锁来实现线程安全。</p><h3 id="主要成员变量及其含义"><a href="#主要成员变量及其含义" class="headerlink" title="主要成员变量及其含义"></a>主要成员变量及其含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;数组最大长度private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;数组默认长度private static final int DEFAULT_CAPACITY &#x3D; 16;&#x2F;&#x2F;默认并发数，在JDK1.7中用来指定segment的默认个数，在1.8中基本已不再使用private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;&#x2F;&#x2F;负载因子private static final float LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表节点数超过8个时转换为红黑树static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;红黑树节点数少于6个时退化为链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;哈希桶数组长度小于64时，链表节点数超过8个，哈希桶数组会优先扩容而不是将链表转化为红黑树static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组扩容时，每个线程负责迁移的节点个数的最小步长private static final int MIN_TRANSFER_STRIDE &#x3D; 16;&#x2F;&#x2F;sizeCtl中用来存储扩容线程个数信息的二进制位数（低16位）private static int RESIZE_STAMP_BITS &#x3D; 16;&#x2F;&#x2F;数组扩容时，最多允许的线程数private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;&#x2F;&#x2F;sizeCtl中用来存储数组大小信息的二进制位数（高16位）private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;&#x2F;&#x2F;哈希桶数组transient volatile Node&lt;K,V&gt;[] table;&#x2F;&#x2F;扩容过程中新的哈希桶数组private transient volatile Node&lt;K,V&gt;[] nextTable;&#x2F;&#x2F;基础数组长度（实际数组长度可能比这个值大）private transient volatile long baseCount;&#x2F;&#x2F;值为-1时代表正在初始化，其他负数代表数组正在进行扩容，扩容时高16位与哈希桶数组大小有关，低16位为扩容的线程数+1;当sizeCtl大于0时，则表示当前哈希桶数组所能容纳的最大元素个数（0.75*数组长度）private transient volatile int sizeCtl;&#x2F;&#x2F;数组扩容时还未被分配扩容线程的最大indexprivate transient volatile int transferIndex;&#x2F;&#x2F;扩容时，CounterCell数组的锁private transient volatile int cellsBusy;&#x2F;&#x2F;扩容时，如果baseCount并发量太高，则将要增加的数组长度放到这个数组中（一般来说，数组长度为baseCount和这个数组中所有元素之和）private transient volatile CounterCell[] counterCells;&#x2F;&#x2F;节点正在被移动时，头节点的hash值static final int MOVED     &#x3D; -1;&#x2F;&#x2F;树形节点根节点的hash值static final int TREEBIN   &#x3D; -2;&#x2F;&#x2F;使用computeIfAbsent方法时，节点的hash值static final int RESERVED  &#x3D; -3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存节点的哈希桶数组使用transient关键字修饰，其目的与HashMap一致，都是因为在同一个对象在不同虚拟机中的hashCode可能不一致，因此对ConcurrentHashMap序列化时只序列化每个节点，反序列化时取出每个节点重新构建哈希桶数组。</p><p>###构造函数<br>####无参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无参构造函数只是一个空实现，没有进行任何处理<br>####有参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap(int initialCapacity,                       float loadFactor, int concurrencyLevel) &#123;  if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)    throw new IllegalArgumentException();  if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins    initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads  long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);  int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : tableSizeFor((int)size);  this.sizeCtl &#x3D; cap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中，根据给定的入参计算出数组初始长度（2^n），并将其赋值给sizeCtl，其中，tableSizeFor函数的实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static final int tableSizeFor(int c) &#123;  int n &#x3D; c - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过位运算，保证数组长度必定位2^n</p><p>###添加元素<br>添加元素使用的是put方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(key, value, false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>内部直接调用了putVal方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;  if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();  &#x2F;&#x2F;计算hash值  int hash &#x3D; spread(key.hashCode());  int binCount &#x3D; 0;  for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;    Node&lt;K,V&gt; f; int n, i, fh;    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;如果哈希桶数组未初始化，则先初始化哈希桶数组      tab &#x3D; initTable();    else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;如果要添加的元素所在的数组位置为空，则直接使用cas操作将元素添加进去，成功则跳出循环      if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))        break;    &#125;    else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)      &#x2F;&#x2F;如果添加的元素所在数组位置头节点被移动了，说明正在进行数组扩容，则当前线程也帮忙进行扩容      tab &#x3D; helpTransfer(tab, f);    else &#123;      V oldVal &#x3D; null;      &#x2F;&#x2F;根据数组位置寻找头节点，然后进行插入，这里对头节点进行加锁并比较，是为了防止代码运行到这里时，扩容和插入同时进行      synchronized (f) &#123;        if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;          if (fh &gt;&#x3D; 0) &#123;            binCount &#x3D; 1;            &#x2F;&#x2F;遍历链表，如果找到key相等且equals方法为true的节点，则修改并返回旧值，否则插入并返回null            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;              K ek;              if (e.hash &#x3D;&#x3D; hash &amp;&amp;                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;                oldVal &#x3D; e.val;                if (!onlyIfAbsent)                    e.val &#x3D; value;                break;              &#125;              Node&lt;K,V&gt; pred &#x3D; e;              if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,value, null);                break;              &#125;            &#125;          &#125;          else if (f instanceof TreeBin) &#123;            &#x2F;&#x2F;如果是树节点，则使用树节点的putVal方法            Node&lt;K,V&gt; p;            binCount &#x3D; 2;            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) !&#x3D; null) &#123;              oldVal &#x3D; p.val;              if (!onlyIfAbsent)                  p.val &#x3D; value;            &#125;          &#125;        &#125;      &#125;      if (binCount !&#x3D; 0) &#123;        &#x2F;&#x2F;插入成功后，判断是否需要将链表变为红黑树        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)          treeifyBin(tab, i);        if (oldVal !&#x3D; null)          return oldVal;        break;      &#125;    &#125;  &#125;  &#x2F;&#x2F;将ConcurrentHashMap的size加一  addCount(1L, binCount);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal方法的执行逻辑为：</p><ol><li>调用spread方法计算插入节点的hash值</li><li>判断哈希桶数组是否为空，如果为空，则先调用initTable方法初始化数组，进入下一次循环</li><li>如果不为空，则找到插入节点所在的数组位置，如果该位置为空，则使用cas操作将要插入的节点放在数组该位置并跳出循环</li><li>如果该位置不为空，则对该位置进行加锁。加锁失败进入下一个循环，加锁成功则先比较数组该位置头节点在加锁前后是否改变，如果改变了，则说明当前在进行扩容，进入下一次循环</li><li>如果没有改变，说明只有当前线程在操作链表（红黑树），先查看头节点哈希值是否大于等于0（树形节点哈希值小于0），如果大于等于0，则数组该位置说明为链表，遍历链表，如果key已经存在，则替换value值，否则在链表结尾添加新节点</li><li>如果头节点的哈希值小于0，则判断是否为树形节点，如果是的话，调用树形节点的putTreeVal方法</li><li>添加元素结束后，调用addCount方法将ConcurrentHashMap的size加一</li></ol><p>如果哈希桶数组未初始化，则会先调用initTable方法进行数组的初始化，其实现如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Node&lt;K,V&gt;[] initTable() &#123;  Node&lt;K,V&gt;[] tab; int sc;  &#x2F;&#x2F;如果一次循环结束哈希桶数组还未初始化，则再次进入循环  while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F;如果sizeCtl小于0，则说明数组正在进行初始化或者正在扩容，让出线程的时间片，进行自旋    if ((sc &#x3D; sizeCtl) &lt; 0)      Thread.yield();    else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;      &#x2F;&#x2F;如果通过cas操作将sc置为-1成功，则说明获得了初始化线程的锁，开始初始化线程      try &#123;        &#x2F;&#x2F;再次判断哈希桶数组是否未初始化，防止其他线程初始化并放入元素后（此时sc&gt;0），本线程获得锁，然后重新将哈希桶数组初始化        if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;          &#x2F;&#x2F;如果sc大于0，则说明ConcurrentHashMap是通过有参构造生成的，此时sc即为数组大小，否则，说明ConcurrentHashMap是通过无参构造生成的，直接使用默认数组大小          int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];          table &#x3D; tab &#x3D; nt;          &#x2F;&#x2F;sc等于0.75n，          sc &#x3D; n - (n &gt;&gt;&gt; 2);        &#125;      &#125; finally &#123;        &#x2F;&#x2F;假如数组初始化后通过cas操作将sizeCtl置为-1，但实际未通过try中的if判断，则需要将sizeCtl改为原来的值；如果进入了if判断，则将sizeCtl改为数组长度的0.75倍        sizeCtl &#x3D; sc;      &#125;      break;    &#125;  &#125;  return tab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>initTable方法执行逻辑为:</p><ol><li>判断哈希桶数组是否未生成，如果未生成则进入循环</li><li>进入循环后判断sizeCtl是否小于0，则说明其他线程正在对数组进行初始化或者扩容，让出线程执行的时间片，进行自旋</li><li>如果大于等于0，通过cas将sizeCtl改为-1。这里也分两种情况，一是哈希桶数组已经初始化(sc&gt;0)，二是哈希桶数组未进行初始化(sc=0)，因此需要继续判断是否哈希桶数组未进行初始化</li><li>如果数组未进行初始化，则进行初始化，并将sizeCtl的值设为初始数组长度的0.75倍；如果数组已经进行了初始化，则将sizeCtl设为原值</li></ol><p>如果当前哈希桶数组正在扩容，会调用helpTransfer方法，将当前线程也加入到扩容线程中，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;  Node&lt;K,V&gt;[] nextTab; int sc;  &#x2F;&#x2F;如果确定要扩容，并且nextTable不为空，则将当前线程加入扩容线程中  if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;    (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;    &#x2F;&#x2F;resizeStamp方法返回的是基于哈希桶数组生成的与数组大小有关的数字，其高16位为0，且第17位为1    int rs &#x3D; resizeStamp(tab.length);    while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;           (sc &#x3D; sizeCtl) &lt; 0) &#123;      &#x2F;&#x2F;if中第一个条件代表当前线程操作的数组和目前ConcurrentHashMap扩容的数组不是同一个数组（大小一致），第二和第三个条件在1.8中实际上是bug，实际上是用来判断数组是否已经扩容完成或是否达到最大扩容线程，第四个判断条件代表数组已扩容完成，如果有任一条件为真，则跳出循环      if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||        sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)        break;      if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;        &#x2F;&#x2F;调用transfer方法进行扩容        transfer(tab, nextTab);        break;      &#125;    &#125;    return nextTab;  &#125;  return table;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>helpTransfer方法的执行逻辑为：</p><ol><li>判断node中记录的nextTable是否为空，如果为空则不做任何操作</li><li>判断当前数组是否正在扩容，如果是，则判断node中记录的nextTab和当前ConcurrentHashMap中正在扩容的nextTable是否不是同一个数组（通过数组长度判断），数组是否已经扩容完成或已经达到最大扩容线程，如果任一条件为空，则直接跳出循环<br>（关于JDK1.8中的bug，详情见<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%89">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427）</a></li><li>如果当前线程可以加入扩容，则将sizeCtl加一，并调用transfer方法进行扩容</li></ol><p>其中transfer方法的实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;如果nextTab为空，则说明要进行扩容，如果不为空，则说明是其他线程来帮助数组扩容private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;  int n &#x3D; tab.length, stride;  &#x2F;&#x2F;stride代表每个线程扩容时，要负责将几个数组元素进行迁移(每个数组元素都是链表或者红黑树)  if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt;  MIN_TRANSFER_STRIDE)      stride &#x3D; MIN_TRANSFER_STRIDE;  &#x2F;&#x2F;如果没有给定扩容之后的nextTab，则需要进行初始化，nextTab长度为老的数组的长度的两倍  if (nextTab &#x3D;&#x3D; null) &#123;      try &#123;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];          nextTab &#x3D; nt;      &#125; catch (Throwable ex) &#123;          sizeCtl &#x3D; Integer.MAX_VALUE;          return;      &#125;      nextTable &#x3D; nextTab;      &#x2F;&#x2F;刚开始时，没有任何线程进行扩容，此时transferIndex代表数组最后，注意，transferIndex被volatite关键字修饰，对所有的线程来说，transferIndex的改变都是可见的      transferIndex &#x3D; n;  &#125;  int nextn &#x3D; nextTab.length;  ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);  boolean advance &#x3D; true;  boolean finishing &#x3D; false;  for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;      Node&lt;K,V&gt; f; int fh;      &#x2F;&#x2F;循环中开始分配当前线程要负责哪些元素的迁移，其中i代表当前线程正在操作的元素的下标（除了第一次循环），bound代表当前线程负责迁移的最小的元素的下标，每个线程总是先迁移下标最大的元素，这里的advance为true代表当前线程可以进行下一个元素的迁移（第一次进入的时候明显为true，之后得确保当前线程已经完成来当前元素的迁移，这样才能进行下一个元素的迁移）      while (advance) &#123;          int nextIndex, nextBound;          if (--i &gt;&#x3D; bound || finishing)              &#x2F;&#x2F;如果当前线程已经完成全部迁移任务，或者所有元素已经完成迁移，跳出循环              advance &#x3D; false;          else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;              &#x2F;&#x2F;如果数组中所有的元素都已经有线程负责迁移，则跳出循环              i &#x3D; -1;              advance &#x3D; false;          &#125;          else if (U.compareAndSwapInt                   (this, TRANSFERINDEX, nextIndex,                    nextBound &#x3D; (nextIndex &gt; stride ?                                 nextIndex - stride : 0))) &#123;              &#x2F;&#x2F;当前线程认领迁移任务，bound代表任务中最小下标，i代表当前操作的元素下标，刚认领任务时，i代表任务中最大下标              bound &#x3D; nextBound;              i &#x3D; nextIndex - 1;              advance &#x3D; false;          &#125;      &#125;      if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;          &#x2F;&#x2F;当前线程已经完成了任务，并且所有数组元素都有线程来负责迁移          int sc;          if (finishing) &#123;              &#x2F;&#x2F;如果所有的线程都已经完成了迁移任务，则将table指向新的哈希桶数组，同时将sizeCtl改为0.75n              nextTable &#x3D; null;              table &#x3D; nextTab;              sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);              return;          &#125;          &#x2F;&#x2F;当前线程已经完成了任务，将其从sizeCtl中减去          if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;              &#x2F;&#x2F;这个判断条件可以判断是否是最后一个线程，false代表当前线程不是最后一个扩容线程。调用transfer方法进行扩容时（入参的nextTab为空），因为调用线程也是一个线程，所以会将（resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT）+ 2赋值给sizeCtl，其中resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT低16位为0，符号位为1，即保证sizeCtl为负数，并且低16位为当前扩容线程+1              if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                  return;              &#x2F;&#x2F;如果是最后一个扩容线程，则将finishing改为true              finishing &#x3D; advance &#x3D; true;              i &#x3D; n;          &#125;      &#125;      else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)          &#x2F;&#x2F;如果该元素为空，则只需要将该元素改为ForwardingNode类型的node          advance &#x3D; casTabAt(tab, i, null, fwd);      else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)          advance &#x3D; true;      else &#123;          synchronized (f) &#123;              &#x2F;&#x2F;再次判断数组中同一位置的节点未变，防止扩容与插入同时进行              if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;                &#x2F;&#x2F;实际的迁移逻辑，重新计算链表&#x2F;红黑树中每个元素的hash值，放到新数组中                  Node&lt;K,V&gt; ln, hn;                  if (fh &gt;&#x3D; 0) &#123;                      int runBit &#x3D; fh &amp; n;                      Node&lt;K,V&gt; lastRun &#x3D; f;                      for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;                          int b &#x3D; p.hash &amp; n;                          if (b !&#x3D; runBit) &#123;                              runBit &#x3D; b;                              lastRun &#x3D; p;                          &#125;                      &#125;                      if (runBit &#x3D;&#x3D; 0) &#123;                          ln &#x3D; lastRun;                          hn &#x3D; null;                      &#125;                      else &#123;                          hn &#x3D; lastRun;                          ln &#x3D; null;                      &#125;                      for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;                          int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;                          if ((ph &amp; n) &#x3D;&#x3D; 0)                              ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);                          else                              hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);                      &#125;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;                  else if (f instanceof TreeBin) &#123;                      TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;                      TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;                      TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;                      int lc &#x3D; 0, hc &#x3D; 0;                      for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;                          int h &#x3D; e.hash;                          TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;                              (h, e.key, e.val, null, null);                          if ((h &amp; n) &#x3D;&#x3D; 0) &#123;                              if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)                                  lo &#x3D; p;                              else                                  loTail.next &#x3D; p;                              loTail &#x3D; p;                              ++lc;                          &#125;                          else &#123;                              if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)                                  hi &#x3D; p;                              else                                  hiTail.next &#x3D; p;                              hiTail &#x3D; p;                              ++hc;                          &#125;                      &#125;                      ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :                          (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                      hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :                          (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;              &#125;          &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入元素后，如果需要将链表转化为红黑树，则会调用treeifyBin方法，treeifyBin方法中同HashMap方法中一样，判断了数组长度是否小于64，如果小于64，则优先扩容</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)  &#x2F;&#x2F;tryPresize内部调用了transfer方法  tryPresize(n &lt;&lt; 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在putVal方法的最后，调用了addCount方法将ConcurrentHashMap的size+1，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final void addCount(long x, int check) &#123;    &#x2F;&#x2F;s代表执行此次addCount后ConcurrentHashMap的长度    CounterCell[] as; long b, s;    if ((as &#x3D; counterCells) !&#x3D; null ||        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;        CounterCell a; long v; int m;        boolean uncontended &#x3D; true;        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||            !(uncontended &#x3D;              U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;            fullAddCount(x, uncontended);            return;        &#125;        if (check &lt;&#x3D; 1)            return;        s &#x3D; sumCount();    &#125;    if (check &gt;&#x3D; 0) &#123;        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;               (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;            int rs &#x3D; resizeStamp(n);            &#x2F;&#x2F;sc小于0则代表在扩容，需要判断是否需要帮助扩容            if (sc &lt; 0) &#123;                &#x2F;&#x2F;if中第一个条件代表当前线程操作的数组和目前ConcurrentHashMap扩容的数组不是同一个数组（大小一致），第二和第三个条件为bug（同上文transfer方法），实际上是用来判断数组是否已经扩容完成或是否达到最大扩容线程，第四个判断条件代表数组已扩容完成，如果有任一条件为真，则跳出循环                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||                    transferIndex &lt;&#x3D; 0)                    break;                &#x2F;&#x2F;如果需要扩容，则当前线程帮助扩容                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            &#x2F;&#x2F;到这一步可以确定sc大于0，此时sc代表ConcurrentHashMap的容量，而while中判断了s&gt;sc，则说明当前ConcurrentHashMap的容量已经达到了上限，需要进行扩容            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s &#x3D; sumCount();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法的执行逻辑为用baseCount来保存ConcurrentHashMap的size，但是如果baseCount的cas操作竞争很激烈，则用CounterCell来保存每次每次putVal时要加的size值，每个线程都会通过getProbe方法获取在CounterCell数组中对应的位置，并将本线程要加的size值放入该位置，如果该位置有值，则会继续寻找数组中为空的元素进行操作</p><p>获取ConcurrentHashMap的size调用的是sumCount方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int size() &#123;    long n &#x3D; sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部调用了sumCount方法，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final long sumCount() &#123;    CounterCell[] as &#x3D; counterCells; CounterCell a;    long sum &#x3D; baseCount;    if (as !&#x3D; null) &#123;        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;            if ((a &#x3D; as[i]) !&#x3D; null)                sum +&#x3D; a.value;        &#125;    &#125;    return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上就是将baseCount和CounterCell中的值相加，就是ConcurrentHashMap的size</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析(JDK1.8)</title>
      <link href="2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在JDK1.8中，HashMap的数据结构为哈希桶数组，哈希桶数组为数组+链表，每个链表的头节点为数组重的一个元素，当链表中元素个数达到8个，并且数组长度大于64时，会将链表转化为红黑树。</p><h3 id="主要成员变量及含义"><a href="#主要成员变量及含义" class="headerlink" title="主要成员变量及含义"></a>主要成员变量及含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;默认数组大小，如果不指定则为16static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16&#x2F;&#x2F;数组最大长度，数值为2^30，当数组长度达到这个值时，数组不会再进行扩容static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;默认负载因子static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表转为红黑树时，链表最少应包含的元素个数static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;哈希桶数组扩容后，如果红黑树中元素个数少于6个，将会退化成链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;链表转化为红黑树时，数组的最小长度（如果数组长度小于64，则会进行扩容而不是将链表转化为红黑树）static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组。transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;当HashMap中包含多少个元素时，将进行扩容int threshold;&#x2F;&#x2F;实际的负载因子final float loadFactor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashMap的哈希桶数组使用transient关键字修饰。其原因主要是对于不同的虚拟机，同一个对象的hashCode的值并不一定一样，也就是对于同一个HashMap，在不同的虚拟机中，同一个元素所在的哈希桶数组的位置可能不一样；因此序列化的时候不保存哈希桶数组而只是保存HashMap中所有的元素，在反序列化的时候将所有元素取出，然后重新构建哈希桶数组。</p><p>不直接使用红黑树存储数据是因为树节点占用的空间大概为链表节点的两倍，而且红黑树插入元素时操作更加复杂。当链表长度为8的时候转化为红黑树是因为根据柏松分布，如果负载因子为0.75时，λ大概为0.5，这种情况下每个链表长度出现的概率为</p><table><thead><tr><th align="left">链表长度</th><th align="center">出现概率</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">0.60653066</td></tr><tr><td align="left">1</td><td align="center">0.30326533</td></tr><tr><td align="left">2</td><td align="center">0.07581633</td></tr><tr><td align="left">3</td><td align="center">0.01263606</td></tr><tr><td align="left">4</td><td align="center">0.00157952</td></tr><tr><td align="left">5</td><td align="center">0.00015795</td></tr><tr><td align="left">6</td><td align="center">0.00001316</td></tr><tr><td align="left">7</td><td align="center">0.00000094</td></tr><tr><td align="left">8</td><td align="center">0.00000006</td></tr></tbody></table><p>可以看到，链表长度为8出现的概率很小，因此这个时候转化为红黑树性价比很高</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap() &#123;  this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>无参构造函数只是将负载因子进行赋值，并没有构造哈希桶数组</p><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap(int initialCapacity, float loadFactor) &#123;  if (initialCapacity &lt; 0)      throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                          initialCapacity);  &#x2F;&#x2F;如果传入的初始数组大小大于最大长度，则取最大长度  if (initialCapacity &gt; MAXIMUM_CAPACITY)      initialCapacity &#x3D; MAXIMUM_CAPACITY;  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))      throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                          loadFactor);  this.loadFactor &#x3D; loadFactor;  this.threshold &#x3D; tableSizeFor(initialCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中对负载因子进行赋值，并根据入参中的初始长度生成threshold（此时的threshold等于数组长度，但在真正构建数组的时候会变为数组长度*负载因子）<br>  tableSizeFor方法代码如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int tableSizeFor(int cap) &#123;  int n &#x3D; cap - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，tableSizeFor中在return前的代码保证了n必定为2的幂次方-1，所以这个方法返回的数组长度必定为2的幂次方</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>HashMap添加元素的方法如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(hash(key), key, value, false, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>hash方法中根据key的hashCode进行了一次hash算法，这种hash算法，将hashCode的高16位和低16位都进行了运算，可以有效减少哈希碰撞，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int hash(Object key) &#123;  int h;  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>真正放入元素的方法为putVal，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;初始化哈希桶数组      n &#x3D; (tab &#x3D; resize()).length;  if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)      &#x2F;&#x2F;如果所在位置的数组元素为空，则直接放入数组该位置      tab[i] &#x3D; newNode(hash, key, value, null);  else &#123;    Node&lt;K,V&gt; e; K k;    &#x2F;&#x2F;这里的e用来保存根据key找到的node，如果不存在，则e为null    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      e &#x3D; p;    else if (p instanceof TreeNode)      &#x2F;&#x2F;如果数组的第一个元素是树形节点，则使用树形节点的putTreeVal方法      e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    else &#123;      &#x2F;&#x2F;到这一步就说明数组中该位置为链表      for (int binCount &#x3D; 0; ; ++binCount) &#123;          &#x2F;&#x2F;遍历链表，如果直到尾部都没有该元素，则在链表尾部新增元素，并判断是否要转变为红黑树        if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;            p.next &#x3D; newNode(hash, key, value, null);            if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)                treeifyBin(tab, hash);            break;        &#125;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            break;        p &#x3D; e;      &#125;    &#125;    &#x2F;&#x2F;如果e不为null，则说明在HashMap中存在put的元素，则将改变该key的value，并返回之前的value    if (e !&#x3D; null) &#123;      V oldValue &#x3D; e.value;      if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)          e.value &#x3D; value;      &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap向双向链表中插入元素      afterNodeAccess(e);      return oldValue;    &#125;  &#125;  ++modCount;  &#x2F;&#x2F;如果HashMap中的元素个数超过最大限度，则哈希桶数组进行扩容  if (++size &gt; threshold)    resize();  &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap根据规则删除node节点（例如LRU删除最早插入的节点）  afterNodeInsertion(evict);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal的主要逻辑如下：</p><ol><li>对哈希桶数组进行判断，如果哈希桶数组还未初始化，则调用resize方法进行初始化;</li><li>将hash值对数组长度进行取模，获取插入元素在数组中的位置，如果数组该位置为空，则直接构造元素，并放入数组对应位置；</li><li>如果数组该位置有值，则在链表（或红黑树）中寻找是否key已经存在，如果存在则修改value，并返回之前的value，如果不存在，则插入链表（或红黑树）中，并判断是否要将链表转化为红黑树；</li><li>判断元素插入后是否需要扩容，如果需要，则调用resize方法进行扩容</li></ol><p>  向链表中插入元素的时候，使用的是尾插法，而不是像JDK1.7中一样使用头插法。主要是因为在JDK1.7中，多线程环境下，如果哈希桶的扩容和元素插入同时进行，有可能会形成环形链表，导致get和put元素时会一直在环形链表中死循环。</p><p>putVal中初始化和扩容时都调用了resize方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) &#123;      &#x2F;&#x2F;如果老数组的长度大于0，则扩容      if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;        &#x2F;&#x2F;如果数组已经达到最大长度，则不进行扩容，直接返回当前数组        threshold &#x3D; Integer.MAX_VALUE;        return oldTab;      &#125;      else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;             oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)        &#x2F;&#x2F;否则将数组长度和threshold翻倍        newThr &#x3D; oldThr &lt;&lt; 1;    &#125;    else if (oldThr &gt; 0)      &#x2F;&#x2F;这里已经确定是数组还未初始化，如果threshold大于0，则说明HashMap是根据有参构造生成的，那么此时的threshold即为数组初始化长度      newCap &#x3D; oldThr;    else &#123;      &#x2F;&#x2F;这里确定数组未初始化，并且是HashMap根据无参构造生成的，因此直接使用默认值即可      newCap &#x3D; DEFAULT_INITIAL_CAPACITY;      newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F;如果HashMap是根据有参构造生成的，newThr并未被赋值，要重新计算threshold的值      float ft &#x3D; (float)newCap * loadFactor;      newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;    if (oldTab !&#x3D; null) &#123;      &#x2F;&#x2F;对扩容后的数组进行填充      for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;        Node&lt;K,V&gt; e;        &#x2F;&#x2F;对数组中每个元素的处理，要注意的是，如果老数组长度为n，元素所处的数组位置为i，则扩容后，这个元素所处的数组位置要么是i，要么是i+n        if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;          oldTab[j] &#x3D; null;          if (e.next &#x3D;&#x3D; null)            newTab[e.hash &amp; (newCap - 1)] &#x3D; e;          else if (e instanceof TreeNode)            &#x2F;&#x2F;对于树节点的处理，方法中判断了重新生成的两棵树是否元素个数大于6，如果不是的话，则红黑树会退化成链表            ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);          else &#123;            &#x2F;&#x2F;对于链表的处理            Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;            Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;            Node&lt;K,V&gt; next;            do &#123;              next &#x3D; e.next;              &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。（只有oldCap为2^n时才能这么判断）              if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                if (loTail &#x3D;&#x3D; null)                  loHead &#x3D; e;                else                  loTail.next &#x3D; e;                loTail &#x3D; e;              &#125;              else &#123;                if (hiTail &#x3D;&#x3D; null)                  hiHead &#x3D; e;                else                  hiTail.next &#x3D; e;                hiTail &#x3D; e;              &#125;            &#125; while ((e &#x3D; next) !&#x3D; null);            if (loTail !&#x3D; null) &#123;              loTail.next &#x3D; null;              newTab[j] &#x3D; loHead;            &#125;            if (hiTail !&#x3D; null) &#123;              hiTail.next &#x3D; null;              newTab[j + oldCap] &#x3D; hiHead;            &#125;          &#125;        &#125;      &#125;    &#125;    return newTab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>resize执行流程：</p><ol><li>判断数组长度是否大于0，如果大于0，说明数组已经初始化，再判断数组长度是否已达上限，达到上限则不进行扩容并直接返回，否则将数组长度和threshold翻倍</li><li>如果数组长度为0，要判断HashMap是根据有参构造方法还是无参构造方法生成的，主要根据threshold是否大于0来判断，有参构造方法生成时，哈希桶数组长度取threshold，如果是无参构造方法生成的HashMap，则将数组长度和threshold都取默认值</li><li>有参构造方法生成的HashMap要重新根据数组长度计算threshold的值</li><li>构造新的哈希桶数组，如果旧的哈希桶数组为null，说明本次是进行数组初始化，直接返回新的哈希桶数组</li><li>如果旧的哈希桶数组不为null，说明本次是进行数组扩容，则遍历数组，将链表（或红黑树）的每个节点重新计算新数组的位置，放入新数组中，如果一个节点处于旧数组的i位置（旧数组长度为n），则它在新数组中要么位于i位置（hash&amp;n==0）要么位于i+n位置（hash&amp;n==1）</li></ol><p>resize方法中扩容时，对树形节点调用了树节点的split方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;  TreeNode&lt;K,V&gt; b &#x3D; this;  TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;  TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;  int lc &#x3D; 0, hc &#x3D; 0;  &#x2F;&#x2F;将一颗红黑树变为两张链表  for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;    next &#x3D; (TreeNode&lt;K,V&gt;)e.next;    e.next &#x3D; null;    &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。    if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;      if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)        loHead &#x3D; e;      else        loTail.next &#x3D; e;      loTail &#x3D; e;      ++lc;    &#125;    else &#123;      if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)        hiHead &#x3D; e;      else        hiTail.next &#x3D; e;      hiTail &#x3D; e;      ++hc;    &#125;  &#125;  if (loHead !&#x3D; null) &#123;    &#x2F;&#x2F;判断是否需要将红黑树转换为链表    if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index] &#x3D; loHead.untreeify(map);    else &#123;      tab[index] &#x3D; loHead;      if (hiHead !&#x3D; null)        loHead.treeify(tab);    &#125;  &#125;  if (hiHead !&#x3D; null) &#123;    &#x2F;&#x2F;同上    if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index + bit] &#x3D; hiHead.untreeify(map);    else &#123;      tab[index + bit] &#x3D; hiHead;      if (loHead !&#x3D; null)        hiHead.treeify(tab);      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>split的逻辑为</p><ol><li>根据头节点取红黑树中的每个每个节点，并根据每个节点的hash值判断处于新数组的哪个位置，处于相同位置的节点构造为一个链表</li><li>每个红黑树迁移后最多变为两张链表，再根据链表中节点个数是否小于等于6来判断两张链表最终会变成链表还是红黑树</li></ol><p>在putVal方法中，构造红黑树调用了treeifyBin方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;  int n, index; Node&lt;K,V&gt; e;  &#x2F;&#x2F;如果哈希桶数组为空，或者数组长度小于64，先扩容，而不是转化为红黑树  if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)    resize();  else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;    do &#123;      TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);      if (tl &#x3D;&#x3D; null)        hd &#x3D; p;      else &#123;        p.prev &#x3D; tl;        tl.next &#x3D; p;      &#125;      tl &#x3D; p;    &#125; while ((e &#x3D; e.next) !&#x3D; null);    if ((tab[index] &#x3D; hd) !&#x3D; null)      hd.treeify(tab);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>treeifyBin方法中首先判断数组是否为空，如果不为空再判断数组长度是否小于64，如果小于64，则调用resize方法进行扩容（resize方法处理链表时并没有将链表转化为红黑树，因此在极端情况下，扩容后链表的元素如果还在数组同一个位置，则会出现元素个数超过8的链表）；如果大于等于64，再将链表转为红黑树</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>获取元素使用的是get方法，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V get(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际是根据getNode方法来获取元素的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;  &#x2F;&#x2F;先根据hash算出所在数组下标，然后遍历链表（红黑树）寻找hashCode等于key并且equals方法也为true的元素，如果有的话则返回，没有的话则返回null  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;    if (first.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      return first;    if ((e &#x3D; first.next) !&#x3D; null) &#123;      if (first instanceof TreeNode)          return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);      do &#123;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;          ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))          return e;      &#125; while ((e &#x3D; e.next) !&#x3D; null);    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>get方法先根据hash值判断要寻找数组中哪个位置，然后遍历链表（或红黑树），找到key相等并且equals为true的节点，返回其value值；如果找不到，则返回null</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>  移除元素使用的是remove方法，实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V remove(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?      null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  实际调用的是removeNode方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                         boolean matchValue, boolean movable) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;  &#x2F;&#x2F;先查找元素  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      node &#x3D; p;    else if ((e &#x3D; p.next) !&#x3D; null) &#123;      if (p instanceof TreeNode)        node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);      else &#123;        do &#123;          if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key ||             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;            node &#x3D; e;            break;          &#125;          p &#x3D; e;        &#125; while ((e &#x3D; e.next) !&#x3D; null);      &#125;    &#125;    &#x2F;&#x2F;如果存在的话则删除    if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||(value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;      if (node instanceof TreeNode)        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);      else if (node &#x3D;&#x3D; p)        tab[index] &#x3D; node.next;      else        p.next &#x3D; node.next;      ++modCount;      --size;      &#x2F;&#x2F;这里是个空实现，主要是为了删除元素后LinkedHashMap对双向链表进行删除      afterNodeRemoval(node);      return node;    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>removeNode方法与get方法获取元素的方式一致，如果找到了对应的key则删除。这里值得注意的一点是树节点的删除，调用了removeTreeNode方法，里面对于红黑树退化成链表的判断逻辑如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是remove可能会导致出现只要4个节点的红黑树</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>  序列化使用的是writeObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void writeObject(java.io.ObjectOutputStream s)    throws IOException &#123;  int buckets &#x3D; capacity();  &#x2F;&#x2F;写入threshold、loadfactor等属性  s.defaultWriteObject();  &#x2F;&#x2F;写入数组大小  s.writeInt(buckets);  &#x2F;&#x2F;写入元素个数  s.writeInt(size);  &#x2F;&#x2F;写入哈希桶数组中每个元素  internalWriteEntries(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化的时候除了常用的属性写入字节流外，还将每个节点写入了字节流</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>  反序列化使用的是readObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;  &#x2F;&#x2F;获取threshold，loadfactor等属性  s.defaultReadObject();  &#x2F;&#x2F;初始化必要的属性  reinitialize();  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))    throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                     loadFactor);  &#x2F;&#x2F;读取写入时的buckets  s.readInt();        &#x2F;&#x2F;读取HashMap中元素的个数            int mappings &#x3D; s.readInt();  if (mappings &lt; 0)    throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +mappings);  else if (mappings &gt; 0) &#123;    &#x2F;&#x2F;根据元素个数确定哈希桶数组大小    float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);    float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;    int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?               DEFAULT_INITIAL_CAPACITY :               (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?               MAXIMUM_CAPACITY :               tableSizeFor((int)fc));    float ft &#x3D; (float)cap * lf;    threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                 (int)ft : Integer.MAX_VALUE);    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];    table &#x3D; tab;    &#x2F;&#x2F;读取每个元素，并调用putVal方法重新构建哈希桶数组    for (int i &#x3D; 0; i &lt; mappings; i++) &#123;      @SuppressWarnings(&quot;unchecked&quot;)      K key &#x3D; (K) s.readObject();      @SuppressWarnings(&quot;unchecked&quot;)      V value &#x3D; (V) s.readObject();      putVal(hash(key), key, value, false, false);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反序列化则是将字节流中的每个元素取出来，再放入到哈希桶数组中</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
