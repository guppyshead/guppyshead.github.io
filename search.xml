<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap源码解析(JDK1.8)</title>
      <link href="2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>  在JDK1.8中，HashMap的数据结构为哈希桶数组，哈希桶数组为数组+链表，每个链表的头节点为数组重的一个元素，当链表中元素个数达到8个，并且数组长度大于64时，会将链表转化为红黑树。</p><h3 id="主要成员变量及含义"><a href="#主要成员变量及含义" class="headerlink" title="主要成员变量及含义"></a>主要成员变量及含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;默认数组大小，如果不指定则为16static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16&#x2F;&#x2F;数组最大长度，数值为2^30，当数组长度达到这个值时，数组不会再进行扩容static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;默认负载因子static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表转为红黑树时，链表最少应包含的元素个数static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;哈希桶数组扩容后，如果红黑树中元素个数少于6个，将会退化成链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;链表转化为红黑树时，数组的最小长度（如果数组长度小于64，则会进行扩容而不是将链表转化为红黑树）static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组。transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;当HashMap中包含多少个元素时，将进行扩容int threshold;&#x2F;&#x2F;实际的负载因子final float loadFactor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  HashMap的哈希桶数组使用transient关键字修饰。其原因主要是对于不同的虚拟机，同一个对象的hashCode的值并不一定一样，也就是对于同一个HashMap，在不同的虚拟机中，同一个元素所在的哈希桶数组的位置可能不一样；因此序列化的时候不保存哈希桶数组而只是保存HashMap中所有的元素，在反序列化的时候将所有元素取出，然后重新构建哈希桶数组。</p><p>  不直接使用红黑树存储数据是因为树节点占用的空间大概为链表节点的两倍，而且红黑树插入元素时操作更加复杂。当链表长度为8的时候转化为红黑树是因为根据柏松分布，如果负载因子为0.75时，λ大概为0.5，这种情况下每个链表长度出现的概率为</p><table><thead><tr><th align="left">链表长度</th><th align="center">出现概率</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">0.60653066</td></tr><tr><td align="left">1</td><td align="center">0.30326533</td></tr><tr><td align="left">2</td><td align="center">0.07581633</td></tr><tr><td align="left">3</td><td align="center">0.01263606</td></tr><tr><td align="left">4</td><td align="center">0.00157952</td></tr><tr><td align="left">5</td><td align="center">0.00015795</td></tr><tr><td align="left">6</td><td align="center">0.00001316</td></tr><tr><td align="left">7</td><td align="center">0.00000094</td></tr><tr><td align="left">8</td><td align="center">0.00000006</td></tr></tbody></table><p>  可以看到，链表长度为8出现的概率很小，因此这个时候转化为红黑树性价比很高</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap() &#123;  this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  无参构造函数只是将负载因子进行赋值，并没有构造哈希桶数组</p><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap(int initialCapacity, float loadFactor) &#123;  if (initialCapacity &lt; 0)      throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                          initialCapacity);  &#x2F;&#x2F;如果传入的初始数组大小大于最大长度，则去最大长度  if (initialCapacity &gt; MAXIMUM_CAPACITY)      initialCapacity &#x3D; MAXIMUM_CAPACITY;  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))      throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                          loadFactor);  this.loadFactor &#x3D; loadFactor;  this.threshold &#x3D; tableSizeFor(initialCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  有参构造函数中对负载因子进行赋值，并根据入参中的初始长度生成threshold（此时的threshold等于数组长度，但在真正构建数组的时候会变为数组长度*负载因子）<br>  tableSizeFor方法代码如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int tableSizeFor(int cap) &#123;  int n &#x3D; cap - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  可以看到，tableSizeFor中在return前的代码保证了n必定为2的幂次方-1，所以这个方法返回的数组长度必定为2的幂次方</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>  HashMap添加元素的方法如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(hash(key), key, value, false, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  hash方法中根据key的hashCode进行了一次hash算法，这种hash算法，将hashCode的高16位和低16位都进行了运算，可以有效减少哈希碰撞，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int hash(Object key) &#123;  int h;  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  真正放入元素的方法为putVal，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  &#x2F;&#x2F;初始化哈希桶数组  if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      n &#x3D; (tab &#x3D; resize()).length;  &#x2F;&#x2F;如果所在位置的数组元素为空，则直接放入数组该位置  if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)      tab[i] &#x3D; newNode(hash, key, value, null);  else &#123;    Node&lt;K,V&gt; e; K k;    &#x2F;&#x2F;这里的e用来保存根据key找到的node，如果不存在，则e为null    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      e &#x3D; p;    else if (p instanceof TreeNode)      &#x2F;&#x2F;如果数组的第一个元素是树形节点，则使用树形节点的putTreeVal方法      e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    else &#123;      &#x2F;&#x2F;到这一步就说明数组中该位置为链表      for (int binCount &#x3D; 0; ; ++binCount) &#123;          &#x2F;&#x2F;遍历链表，如果直到尾部都没有该元素，则在链表尾部新增元素，并判断是否要转变为红黑树        if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;            p.next &#x3D; newNode(hash, key, value, null);            if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)                treeifyBin(tab, hash);            break;        &#125;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            break;        p &#x3D; e;      &#125;    &#125;    &#x2F;&#x2F;如果e不为null，则说明在HashMap中存在put的元素，则将改变该key的value，并返回之前的value    if (e !&#x3D; null) &#123;      V oldValue &#x3D; e.value;      if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)          e.value &#x3D; value;      &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap向双向链表中插入元素      afterNodeAccess(e);      return oldValue;    &#125;  &#125;  ++modCount;  &#x2F;&#x2F;如果HashMap中的元素个数超过最大限度，则哈希桶数组进行扩容  if (++size &gt; threshold)    resize();  &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap根据规则删除node节点（例如LRU删除最早插入的节点）  afterNodeInsertion(evict);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  putVal的主要逻辑如下：</p><ol><li>对哈希桶数组进行判断，如果哈希桶数组还未初始化，则调用resize方法进行初始化;</li><li>将hash值对数组长度进行取模，获取插入元素在数组中的位置，如果数组该位置为空，则直接构造元素，并放入数组对应位置；</li><li>如果数组该位置有值，则在链表（或红黑树）中寻找是否key已经存在，如果存在则修改value，并返回之前的value，如果不存在，则插入链表（或红黑树）中，并判断是否要将链表转化为红黑树；</li><li>判断元素插入后是否需要扩容，如果需要，则调用resize方法进行扩容</li></ol><p>  向链表中插入元素的时候，使用的是尾插法，而不是像JDK1.7中一样使用头插法。主要是因为在JDK1.7中，多线程环境下，如果哈希桶的扩容和元素插入同时进行，有可能会形成环形链表，导致get和put元素时会一直在环形链表中死循环。</p><p>  putVal中初始化和扩容时都调用了resize方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    &#x2F;&#x2F;如果老数组的长度大于0，则扩容    if (oldCap &gt; 0) &#123;      &#x2F;&#x2F;如果数组已经达到最大长度，则不进行扩容，直接返回当前数组      if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;        threshold &#x3D; Integer.MAX_VALUE;        return oldTab;      &#125;      &#x2F;&#x2F;否则将数组长度和threshold翻倍      else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;             oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)        newThr &#x3D; oldThr &lt;&lt; 1;    &#125;    else if (oldThr &gt; 0)      &#x2F;&#x2F;这里已经确定是数组还未初始化，如果threshold大于0，则说明HashMap是根据有参构造生成的，那么此时的threshold即为数组初始化长度      newCap &#x3D; oldThr;    else &#123;      &#x2F;&#x2F;这里确定数组未初始化，并且是HashMap根据无参构造生成的，因此直接使用默认值即可      newCap &#x3D; DEFAULT_INITIAL_CAPACITY;      newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    &#x2F;&#x2F;如果HashMap是根据有参构造生成的，newThr并未被赋值，要重新计算threshold的值    if (newThr &#x3D;&#x3D; 0) &#123;      float ft &#x3D; (float)newCap * loadFactor;      newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;    &#x2F;&#x2F;对扩容后的数组进行填充    if (oldTab !&#x3D; null) &#123;      for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;        Node&lt;K,V&gt; e;        &#x2F;&#x2F;对数组中每个元素的处理，要注意的是，如果老数组长度为n，元素所处的数组位置为i，则扩容后，这个元素所处的数组位置要么是i，要么是i+n        if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;          oldTab[j] &#x3D; null;          if (e.next &#x3D;&#x3D; null)            newTab[e.hash &amp; (newCap - 1)] &#x3D; e;          else if (e instanceof TreeNode)            &#x2F;&#x2F;对于树节点的处理，方法中判断了重新生成的两棵树是否元素个数大于6，如果不是的话，则红黑树会退化成链表            ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);          else &#123;            &#x2F;&#x2F;对于链表的处理            Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;            Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;            Node&lt;K,V&gt; next;            do &#123;              next &#x3D; e.next;              &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。（只有oldCap为2^n时才能这么判断）              if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                if (loTail &#x3D;&#x3D; null)                  loHead &#x3D; e;                else                  loTail.next &#x3D; e;                loTail &#x3D; e;              &#125;              else &#123;                if (hiTail &#x3D;&#x3D; null)                  hiHead &#x3D; e;                else                  hiTail.next &#x3D; e;                hiTail &#x3D; e;              &#125;            &#125; while ((e &#x3D; next) !&#x3D; null);            if (loTail !&#x3D; null) &#123;              loTail.next &#x3D; null;              newTab[j] &#x3D; loHead;            &#125;            if (hiTail !&#x3D; null) &#123;              hiTail.next &#x3D; null;              newTab[j + oldCap] &#x3D; hiHead;            &#125;          &#125;        &#125;      &#125;    &#125;    return newTab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  resize方法中扩容时，对树形节点调用了树节点的split方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;  TreeNode&lt;K,V&gt; b &#x3D; this;  TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;  TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;  int lc &#x3D; 0, hc &#x3D; 0;  &#x2F;&#x2F;将一颗红黑树变为两颗红黑树  for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;    next &#x3D; (TreeNode&lt;K,V&gt;)e.next;    e.next &#x3D; null;    &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。    if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;      if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)        loHead &#x3D; e;      else        loTail.next &#x3D; e;      loTail &#x3D; e;      ++lc;    &#125;    else &#123;      if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)        hiHead &#x3D; e;      else        hiTail.next &#x3D; e;      hiTail &#x3D; e;      ++hc;    &#125;  &#125;  if (loHead !&#x3D; null) &#123;    &#x2F;&#x2F;判断是否需要将红黑树转换为链表    if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index] &#x3D; loHead.untreeify(map);    else &#123;      tab[index] &#x3D; loHead;      if (hiHead !&#x3D; null)        loHead.treeify(tab);    &#125;  &#125;  if (hiHead !&#x3D; null) &#123;    &#x2F;&#x2F;同上    if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index + bit] &#x3D; hiHead.untreeify(map);    else &#123;      tab[index + bit] &#x3D; hiHead;      if (loHead !&#x3D; null)        hiHead.treeify(tab);      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在putVal方法中，构造红黑树调用了treeifyBin方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;    int n, index; Node&lt;K,V&gt; e;    &#x2F;&#x2F;如果哈希桶数组为空，或者数组长度小于64，先扩容，而不是转化为红黑树    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)      resize();    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;      TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;      do &#123;        TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);        if (tl &#x3D;&#x3D; null)          hd &#x3D; p;        else &#123;          p.prev &#x3D; tl;          tl.next &#x3D; p;        &#125;        tl &#x3D; p;      &#125; while ((e &#x3D; e.next) !&#x3D; null);      if ((tab[index] &#x3D; hd) !&#x3D; null)        hd.treeify(tab);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>  获取元素使用的是get方法，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V get(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  实际是根据getNode方法来获取元素的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;  &#x2F;&#x2F;先根据hash算出所在数组下标，然后遍历链表（红黑树）寻找hashCode等于key并且equals方法也为true的元素，如果有的话则返回，没有的话则返回null  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;    if (first.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      return first;    if ((e &#x3D; first.next) !&#x3D; null) &#123;      if (first instanceof TreeNode)          return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);      do &#123;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;          ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))          return e;      &#125; while ((e &#x3D; e.next) !&#x3D; null);    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>  移除元素使用的是remove方法，实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V remove(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?      null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  实际调用的是removeNode方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                         boolean matchValue, boolean movable) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;  &#x2F;&#x2F;先查找元素  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      node &#x3D; p;    else if ((e &#x3D; p.next) !&#x3D; null) &#123;      if (p instanceof TreeNode)        node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);      else &#123;        do &#123;          if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key ||             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;            node &#x3D; e;            break;          &#125;          p &#x3D; e;        &#125; while ((e &#x3D; e.next) !&#x3D; null);      &#125;    &#125;    &#x2F;&#x2F;如果存在的话则删除    if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||(value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;      if (node instanceof TreeNode)        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);      else if (node &#x3D;&#x3D; p)        tab[index] &#x3D; node.next;      else        p.next &#x3D; node.next;      ++modCount;      --size;      &#x2F;&#x2F;这里是个空实现，主要是为了删除元素后LinkedHashMap对双向链表进行删除      afterNodeRemoval(node);      return node;    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>  序列化使用的是writeObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void writeObject(java.io.ObjectOutputStream s)    throws IOException &#123;  int buckets &#x3D; capacity();  &#x2F;&#x2F;写入threshold、loadfactor等属性  s.defaultWriteObject();  &#x2F;&#x2F;写入数组大小  s.writeInt(buckets);  &#x2F;&#x2F;写入元素个数  s.writeInt(size);  &#x2F;&#x2F;写入哈希桶数组中每个元素  internalWriteEntries(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>  反序列化使用的是readObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;  &#x2F;&#x2F;获取threshold，loadfactor等属性  s.defaultReadObject();  &#x2F;&#x2F;初始化必要的属性  reinitialize();  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))    throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                     loadFactor);  &#x2F;&#x2F;读取写入时的buckets  s.readInt();        &#x2F;&#x2F;读取HashMap中元素的个数            int mappings &#x3D; s.readInt();  if (mappings &lt; 0)    throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +mappings);  else if (mappings &gt; 0) &#123;    &#x2F;&#x2F;根据元素个数确定哈希桶数组大小    float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);    float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;    int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?               DEFAULT_INITIAL_CAPACITY :               (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?               MAXIMUM_CAPACITY :               tableSizeFor((int)fc));    float ft &#x3D; (float)cap * lf;    threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                 (int)ft : Integer.MAX_VALUE);    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];    table &#x3D; tab;    &#x2F;&#x2F;读取每个元素，并调用putVal方法重新构建哈希桶数组    for (int i &#x3D; 0; i &lt; mappings; i++) &#123;      @SuppressWarnings(&quot;unchecked&quot;)      K key &#x3D; (K) s.readObject();      @SuppressWarnings(&quot;unchecked&quot;)      V value &#x3D; (V) s.readObject();      putVal(hash(key), key, value, false, false);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
