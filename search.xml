<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring源码解析(四)</title>
      <link href="2021/08/28/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E5%9B%9B)/"/>
      <url>2021/08/28/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>Spring中获取FactoryBean所表示的bean取的是其getObject方法中返回的bean，在初始化bean的时候，对于普通的bean和FactoryBean，Spring的处理逻辑是不同的。</p><h3 id="初始化Bean"><a href="#初始化Bean" class="headerlink" title="初始化Bean"></a>初始化Bean</h3><p>在Spring启动流程中，注册完所有的Listener之后，Spring会将初始化所有非懒加载的bean</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> initApplicationEventMulticaster();onRefresh();registerListeners(); &#x2F;&#x2F;初始化非懒加载的beanfinishBeanFactoryInitialization(beanFactory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>finishBeanFactoryInitialization方法的具体实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;&#x2F;&#x2F;注册ConversionService用来对bean的property进行辅助解析if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;beanFactory.setConversionService(beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));&#125;if (!beanFactory.hasEmbeddedValueResolver()) &#123;beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));&#125;String[] weaverAwareNames &#x3D; beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);for (String weaverAwareName : weaverAwareNames) &#123;getBean(weaverAwareName);&#125;beanFactory.setTempClassLoader(null);beanFactory.freezeConfiguration();&#x2F;&#x2F;初始化所有非懒加载的beanbeanFactory.preInstantiateSingletons();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个方法的最后一句beanFactory.preInstantiateSingletons()，初始化了非懒加载的bean</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public void preInstantiateSingletons() throws BeansException &#123;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Pre-instantiating singletons in &quot; + this);&#125;   &#x2F;&#x2F;获取BeanFacotry中注册的所有bean的nameList&lt;String&gt; beanNames &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames);   &#x2F;&#x2F;遍历所有的beanName，并初始化for (String beanName : beanNames) &#123;RootBeanDefinition bd &#x3D; getMergedLocalBeanDefinition(beanName);if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;       &#x2F;&#x2F;判断是否是FactoryBean，如果是的化，进行初始化if (isFactoryBean(beanName)) &#123;Object bean &#x3D; getBean(FACTORY_BEAN_PREFIX + beanName);if (bean instanceof FactoryBean) &#123;FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) bean;boolean isEagerInit;if (System.getSecurityManager() !&#x3D; null &amp;&amp; factory instanceof SmartFactoryBean) &#123;isEagerInit &#x3D; AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,getAccessControlContext());&#125;else &#123;isEagerInit &#x3D; (factory instanceof SmartFactoryBean &amp;&amp;((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());&#125;if (isEagerInit) &#123;getBean(beanName);&#125;&#125;&#125;else &#123;getBean(beanName);&#125;&#125;&#125;&#x2F;&#x2F;如果是SmartInitializingSingleton，需要判断是否要触发afterSingletonsInstantiated方法for (String beanName : beanNames) &#123;Object singletonInstance &#x3D; getSingleton(beanName);if (singletonInstance instanceof SmartInitializingSingleton) &#123;StartupStep smartInitialize &#x3D; this.getApplicationStartup().start(&quot;spring.beans.smart-initialize&quot;).tag(&quot;beanName&quot;, beanName);SmartInitializingSingleton smartSingleton &#x3D; (SmartInitializingSingleton) singletonInstance;if (System.getSecurityManager() !&#x3D; null) &#123;AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;smartSingleton.afterSingletonsInstantiated();return null;&#125;, getAccessControlContext());&#125;else &#123;smartSingleton.afterSingletonsInstantiated();&#125;smartInitialize.end();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化bean时，首先判断了bean是否是FactoryBean</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> @Overridepublic boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException &#123;   &#x2F;&#x2F;将beanName转化为正常的beanName，因为FacotryBean的beanName会带有前缀&amp;String beanName &#x3D; transformedBeanName(name);   &#x2F;&#x2F;在缓存中寻找beanObject beanInstance &#x3D; getSingleton(beanName, false);   &#x2F;&#x2F;如果存在beanName对应的bean，则判断这个bean是不是FactoryBeanif (beanInstance !&#x3D; null) &#123;return (beanInstance instanceof FactoryBean);&#125;&#x2F;&#x2F;如果这个BeanFactory中不包含这个beanName，去父BeanFactory中判断beanName对应的bean是否为FactoryBeanif (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;return ((ConfigurableBeanFactory) getParentBeanFactory()).isFactoryBean(name);&#125;   &#x2F;&#x2F;这个BeanFactory中包含beanName，判断是否是FactoryBeanreturn isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在缓存中寻找bean的时候，是从Spring的三级缓存中寻找</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;Object singletonObject &#x3D; this.singletonObjects.get(beanName);if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;singletonObject &#x3D; this.earlySingletonObjects.get(beanName);if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;synchronized (this.singletonObjects) &#123;singletonObject &#x3D; this.singletonObjects.get(beanName);if (singletonObject &#x3D;&#x3D; null) &#123;singletonObject &#x3D; this.earlySingletonObjects.get(beanName);if (singletonObject &#x3D;&#x3D; null) &#123;ObjectFactory&lt;?&gt; singletonFactory &#x3D; this.singletonFactories.get(beanName);if (singletonFactory !&#x3D; null) &#123;singletonObject &#x3D; singletonFactory.getObject();this.earlySingletonObjects.put(beanName, singletonObject);this.singletonFactories.remove(beanName);&#125;&#125;&#125;&#125;&#125;&#125;return singletonObject;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三级缓存代表的意义为</p><ul><li>singletonObject:保存beanName和bean实例之间的映射关系，这里面存储的bean通常已经完全实例化(初始化完成+属性已填充)</li><li>earlySingletonObjects:保存beanName和bean实例之间的映射关系，这里存储的bean通常只是完成了初始化，而且在初始化后被其他bean依赖</li><li>singletonFactories:保存beanName和ObjectFactory之间的映射关系，这里存储的bean通常只是完成了初始化，但是bean还没有被其他bean依赖<br>因此可以看到，如果getSingleton的时候如果在singletonFactories中找到了bean，则会将其从singletonFactories中移除，放入earlySingletonObjects中</li></ul><h3 id="初始化FacotryBean"><a href="#初始化FacotryBean" class="headerlink" title="初始化FacotryBean"></a>初始化FacotryBean</h3><p>在经过了上面的判断后，如果一个beanName对应的是FactoryBean，则会调用getBean方法获取FactoryBean</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;String FACTORY_BEAN_PREFIX &#x3D; &quot;&amp;&quot;;Object bean &#x3D; getBean(FACTORY_BEAN_PREFIX + beanName);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>getBean实际调用的是doGetBean方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected &lt;T&gt; T doGetBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)throws BeansException &#123;String beanName &#x3D; transformedBeanName(name);Object beanInstance;&#x2F;&#x2F;判断三级混存中是否含有beanName对应的beanObject sharedInstance &#x3D; getSingleton(beanName);if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;if (logger.isTraceEnabled()) &#123;if (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +&quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);&#125;else &#123;logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);&#125;&#125;beanInstance &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);&#125;else &#123;if (isPrototypeCurrentlyInCreation(beanName)) &#123;throw new BeanCurrentlyInCreationException(beanName);&#125;BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;String nameToLookup &#x3D; originalBeanName(name);if (parentBeanFactory instanceof AbstractBeanFactory) &#123;return ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);&#125;else if (args !&#x3D; null) &#123;return (T) parentBeanFactory.getBean(nameToLookup, args);&#125;else if (requiredType !&#x3D; null) &#123;return parentBeanFactory.getBean(nameToLookup, requiredType);&#125;else &#123;return (T) parentBeanFactory.getBean(nameToLookup);&#125;&#125;if (!typeCheckOnly) &#123;markBeanAsCreated(beanName);&#125;StartupStep beanCreation &#x3D; this.applicationStartup.start(&quot;spring.beans.instantiate&quot;).tag(&quot;beanName&quot;, name);try &#123;if (requiredType !&#x3D; null) &#123;beanCreation.tag(&quot;beanType&quot;, requiredType::toString);&#125;RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);checkMergedBeanDefinition(mbd, beanName, args);String[] dependsOn &#x3D; mbd.getDependsOn();if (dependsOn !&#x3D; null) &#123;for (String dep : dependsOn) &#123;if (isDependent(beanName, dep)) &#123;throw new BeanCreationException(mbd.getResourceDescription(), beanName,&quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);&#125;registerDependentBean(dep, beanName);try &#123;getBean(dep);&#125;catch (NoSuchBeanDefinitionException ex) &#123;throw new BeanCreationException(mbd.getResourceDescription(), beanName,&quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);&#125;&#125;&#125;if (mbd.isSingleton()) &#123;sharedInstance &#x3D; getSingleton(beanName, () -&gt; &#123;try &#123;return createBean(beanName, mbd, args);&#125;catch (BeansException ex) &#123;destroySingleton(beanName);throw ex;&#125;&#125;);beanInstance &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;else if (mbd.isPrototype()) &#123;Object prototypeInstance &#x3D; null;try &#123;beforePrototypeCreation(beanName);prototypeInstance &#x3D; createBean(beanName, mbd, args);&#125;finally &#123;afterPrototypeCreation(beanName);&#125;beanInstance &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;else &#123;String scopeName &#x3D; mbd.getScope();if (!StringUtils.hasLength(scopeName)) &#123;throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;&#39;&quot;);&#125;Scope scope &#x3D; this.scopes.get(scopeName);if (scope &#x3D;&#x3D; null) &#123;throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);&#125;try &#123;Object scopedInstance &#x3D; scope.get(beanName, () -&gt; &#123;beforePrototypeCreation(beanName);try &#123;return createBean(beanName, mbd, args);&#125;finally &#123;afterPrototypeCreation(beanName);&#125;&#125;);beanInstance &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;catch (IllegalStateException ex) &#123;throw new ScopeNotActiveException(beanName, scopeName, ex);&#125;&#125;&#125;catch (BeansException ex) &#123;beanCreation.tag(&quot;exception&quot;, ex.getClass().toString());beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage()));cleanupAfterBeanCreationFailure(beanName);throw ex;&#125;finally &#123;beanCreation.end();&#125;&#125;return adaptBeanInstance(name, beanInstance, requiredType);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上所有的bean实例化时都会调用doGetBean方法，而doGetBean的每个逻辑分支最后都会走到getObjectForBeanInstance方法，Spring正是在这个方法中对FactoryBean进行处理的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;if (BeanFactoryUtils.isFactoryDereference(name)) &#123;if (beanInstance instanceof NullBean) &#123;return beanInstance;&#125;if (!(beanInstance instanceof FactoryBean)) &#123;throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());&#125;if (mbd !&#x3D; null) &#123;mbd.isFactoryBean &#x3D; true;&#125;return beanInstance;&#125;if (!(beanInstance instanceof FactoryBean)) &#123;return beanInstance;&#125;Object object &#x3D; null;if (mbd !&#x3D; null) &#123;mbd.isFactoryBean &#x3D; true;&#125;else &#123;object &#x3D; getCachedObjectForFactoryBean(beanName);&#125;   &#x2F;&#x2F;获取FactoryBeanif (object &#x3D;&#x3D; null) &#123;FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) beanInstance;if (mbd &#x3D;&#x3D; null &amp;&amp; containsBeanDefinition(beanName)) &#123;mbd &#x3D; getMergedLocalBeanDefinition(beanName);&#125;boolean synthetic &#x3D; (mbd !&#x3D; null &amp;&amp; mbd.isSynthetic());object &#x3D; getObjectFromFactoryBean(factory, beanName, !synthetic);&#125;return object;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在方法最后调用了getObjectFromFactoryBean方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;  &#x2F;&#x2F;···省略若干代码  object &#x3D; this.doGetObjectFromFactoryBean(factory, beanName);  &#x2F;&#x2F;···省略若干代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在doGetObjectFromFactoryBean中调用了factory的getObject方法，也就是FactoryBean的getObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Object doGetObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName) throws BeanCreationException &#123;  &#x2F;&#x2F;···省略若干代码  object &#x3D; factory.getObject();  &#x2F;&#x2F;···省略若干代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析(三)</title>
      <link href="2021/08/14/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)/"/>
      <url>2021/08/14/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>在Spring中，除了alias、bean、import、beans四种类型的默认标签，剩下的都属于自定义标签，对于自定义标签，Spring解析的逻辑和默认标签的解析逻辑并不相同。本文主要探讨自定义标签的解析。</p><h3 id="自定义标签解析"><a href="#自定义标签解析" class="headerlink" title="自定义标签解析"></a>自定义标签解析</h3><p>自定义标签的解析使用的是BeanDefinitionParserDelegate的parseCustomElement方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) &#123;   &#x2F;&#x2F;解析nameSpaceString namespaceUri &#x3D; getNamespaceURI(ele);if (namespaceUri &#x3D;&#x3D; null) &#123;return null;&#125;   &#x2F;&#x2F;根据nameSpace查找处理器NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);if (handler &#x3D;&#x3D; null) &#123;error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);return null;&#125;   &#x2F;&#x2F;处理自定义标签return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析自定义标签时，首先会根据标签获取命名空间，命名空间通常是在xml根节点声明的</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-3.0.xsd&quot;&gt;    &lt;aop:aspectj-autoproxy&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中xmls:aop指定的是处理器的地址，而xsi:schemaLocation中指定的则是约束文件的地址。<br>执行parseCustomElement方法时，getNamespaceURI方法取到的是处理器的地址，得到handler地址后，会从readerContext的getnamespaceHandlerResolver获取所有的handler，然后选出namespace对应的handler来处理xml文件<br>readerContext构造时会需要传入DefaultNamespaceHandlerResolver，而DefaultNamespaceHandlerResolver构造时默认的handler的地址为 META-INF/spring.handlers</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION &#x3D; &quot;META-INF&#x2F;spring.handlers&quot;;  public DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader) &#123;this(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);&#125;  public DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader, String handlerMappingsLocation) &#123;Assert.notNull(handlerMappingsLocation, &quot;Handler mappings location must not be null&quot;);this.classLoader &#x3D; (classLoader !&#x3D; null ? classLoader : ClassUtils.getDefaultClassLoader());this.handlerMappingsLocation &#x3D; handlerMappingsLocation;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如aop标签的spring.handlers的配置如下</p><pre class="line-numbers language-none"><code class="language-none">http\:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x3D;org.springframework.aop.config.AopNamespaceHandler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用resolve解析handler时，会调用handlerMappings方法获取已经配置的所有handler</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public NamespaceHandler resolve(String namespaceUri) &#123;   &#x2F;&#x2F;获取handlerMappingsMap&lt;String, Object&gt; handlerMappings &#x3D; getHandlerMappings();Object handlerOrClassName &#x3D; handlerMappings.get(namespaceUri);if (handlerOrClassName &#x3D;&#x3D; null) &#123;return null;&#125;else if (handlerOrClassName instanceof NamespaceHandler) &#123;return (NamespaceHandler) handlerOrClassName;&#125;else &#123;String className &#x3D; (String) handlerOrClassName;try &#123;Class&lt;?&gt; handlerClass &#x3D; ClassUtils.forName(className, this.classLoader);if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;throw new FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri +&quot;] does not implement the [&quot; + NamespaceHandler.class.getName() + &quot;] interface&quot;);&#125;NamespaceHandler namespaceHandler &#x3D; (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);namespaceHandler.init();handlerMappings.put(namespaceUri, namespaceHandler);return namespaceHandler;&#125;catch (ClassNotFoundException ex) &#123;throw new FatalBeanException(&quot;Could not find NamespaceHandler class [&quot; + className +&quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, ex);&#125;catch (LinkageError err) &#123;throw new FatalBeanException(&quot;Unresolvable class definition for NamespaceHandler class [&quot; +className + &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;, err);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getHandlerMappings方法实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> private Map&lt;String, Object&gt; getHandlerMappings() &#123;Map&lt;String, Object&gt; handlerMappings &#x3D; this.handlerMappings;if (handlerMappings &#x3D;&#x3D; null) &#123;synchronized (this) &#123;handlerMappings &#x3D; this.handlerMappings;if (handlerMappings &#x3D;&#x3D; null) &#123;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Loading NamespaceHandler mappings from [&quot; + this.handlerMappingsLocation + &quot;]&quot;);&#125;try &#123;           &#x2F;&#x2F;获取 META-INF&#x2F;spring.handlers 文件中配置的handler并存储在Properties对象中Properties mappings &#x3D;PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Loaded NamespaceHandler mappings: &quot; + mappings);&#125;handlerMappings &#x3D; new ConcurrentHashMap&lt;&gt;(mappings.size());CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);this.handlerMappings &#x3D; handlerMappings;&#125;catch (IOException ex) &#123;throw new IllegalStateException(&quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;, ex);&#125;&#125;&#125;&#125;return handlerMappings;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取到handler后，会调用handler的parse方法解析自定义标签，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;    &#x2F;&#x2F;获取解析自定义标签的parser    BeanDefinitionParser parser &#x3D; this.findParserForElement(element, parserContext);    return parser !&#x3D; null ? parser.parse(element, parserContext) : null;&#125;private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123;    &#x2F;&#x2F;获取自定义标签的名称，如aop标签中的aspectj-autoproxy    String localName &#x3D; parserContext.getDelegate().getLocalName(element);    &#x2F;&#x2F;获取标签名对应的parser    BeanDefinitionParser parser &#x3D; (BeanDefinitionParser)this.parsers.get(localName);    if (parser &#x3D;&#x3D; null) &#123;        parserContext.getReaderContext().fatal(&quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);    &#125;    return parser;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于aop标签，其parser的源码如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;@Overridepublic void init() &#123;registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser());registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator());registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于aop并不需要返回任何bean，因此AspectJAutoProxyBeanDefinitionParser只实现了BeanDefinitionParser接口，在执行parser.parse(element, parserContext)这一行的时候会调用AspectJAutoProxyBeanDefinitionParser的parse方法。但对于我们自己写的parser，一般都是继承AbstractSingleBeanDefinitionParser，然后重写doParse(Element element, BeanDefinitionBuilder builder)方法并将我们自定义的bean放入入参的BeanDefinitionBuilder中，这段逻辑是在parse方法中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public final BeanDefinition parse(Element element, ParserContext parserContext) &#123;   &#x2F;&#x2F;解析自定义标签并得到解析后的BeanDefinitionAbstractBeanDefinition definition &#x3D; parseInternal(element, parserContext);if (definition !&#x3D; null &amp;&amp; !parserContext.isNested()) &#123;try &#123;String id &#x3D; resolveId(element, definition, parserContext);if (!StringUtils.hasText(id)) &#123;parserContext.getReaderContext().error(&quot;Id is required for element &#39;&quot; + parserContext.getDelegate().getLocalName(element)+ &quot;&#39; when used as a top-level tag&quot;, element);&#125;String[] aliases &#x3D; null;if (shouldParseNameAsAliases()) &#123;String name &#x3D; element.getAttribute(NAME_ATTRIBUTE);if (StringUtils.hasLength(name)) &#123;aliases &#x3D; StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));&#125;&#125;BeanDefinitionHolder holder &#x3D; new BeanDefinitionHolder(definition, id, aliases);registerBeanDefinition(holder, parserContext.getRegistry());if (shouldFireEvents()) &#123;BeanComponentDefinition componentDefinition &#x3D; new BeanComponentDefinition(holder);postProcessComponentDefinition(componentDefinition);parserContext.registerComponent(componentDefinition);&#125;&#125;catch (BeanDefinitionStoreException ex) &#123;String msg &#x3D; ex.getMessage();parserContext.getReaderContext().error((msg !&#x3D; null ? msg : ex.toString()), element);return null;&#125;&#125;return definition;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析标签在方法中的第一行parseInternal方法中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) &#123;    BeanDefinitionBuilder builder &#x3D; BeanDefinitionBuilder.genericBeanDefinition();    String parentName &#x3D; this.getParentName(element);    if (parentName !&#x3D; null) &#123;        builder.getRawBeanDefinition().setParentName(parentName);    &#125;    Class&lt;?&gt; beanClass &#x3D; this.getBeanClass(element);    if (beanClass !&#x3D; null) &#123;        builder.getRawBeanDefinition().setBeanClass(beanClass);    &#125; else &#123;        String beanClassName &#x3D; this.getBeanClassName(element);        if (beanClassName !&#x3D; null) &#123;            builder.getRawBeanDefinition().setBeanClassName(beanClassName);        &#125;    &#125;    builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));    BeanDefinition containingBd &#x3D; parserContext.getContainingBeanDefinition();    if (containingBd !&#x3D; null) &#123;        builder.setScope(containingBd.getScope());    &#125;    if (parserContext.isDefaultLazyInit()) &#123;        builder.setLazyInit(true);    &#125;    &#x2F;&#x2F;解析标签    this.doParse(element, parserContext, builder);    return builder.getBeanDefinition();&#125;&#x2F;&#x2F;交给子类重写，例如我们自己定义的parserprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析(二)</title>
      <link href="2021/07/31/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
      <url>2021/07/31/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>上篇文章讲了Spring读取xml的过程，在Spring将xml加载到内存后，就要对xml的标签进行解析，对xml中的标签解析分为两类，一类是Spring默认标签(alias、bean、import、beans)的解析，一类是自定义标签(tx、context、task等)的解析。本文主要探究默认标签的解析。</p><h4 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h4><p>书接上文，解析标签的代码是</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;    if (delegate.isDefaultNamespace(root)) &#123;        NodeList nl &#x3D; root.getChildNodes();        for(int i &#x3D; 0; i &lt; nl.getLength(); ++i) &#123;            Node node &#x3D; nl.item(i);            if (node instanceof Element) &#123;                Element ele &#x3D; (Element)node;                if (delegate.isDefaultNamespace(ele)) &#123;                    this.parseDefaultElement(ele, delegate);                &#125; else &#123;                    delegate.parseCustomElement(ele);                &#125;            &#125;        &#125;    &#125; else &#123;        delegate.parseCustomElement(root);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑也很简单，如果根标签是默认标签，则使用默认标签的解析方式来解析根标签，否则使用用户自定的解析方式解析标签，对于根标签的子标签也是进行这种判断。解析默认标签时，使用的是parseCustomElement方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;    if (delegate.nodeNameEquals(ele, &quot;import&quot;)) &#123;        this.importBeanDefinitionResource(ele);    &#125; else if (delegate.nodeNameEquals(ele, &quot;alias&quot;)) &#123;        this.processAliasRegistration(ele);    &#125; else if (delegate.nodeNameEquals(ele, &quot;bean&quot;)) &#123;        this.processBeanDefinition(ele, delegate);    &#125; else if (delegate.nodeNameEquals(ele, &quot;beans&quot;)) &#123;        this.doRegisterBeanDefinitions(ele);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对不同的默认标签解析调用了不同的方法</p><h2 id="解析bean标签"><a href="#解析bean标签" class="headerlink" title="解析bean标签"></a>解析bean标签</h2><p>解析bean标签时，调用的是processBeanDefinition方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;    BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);    if (bdHolder !&#x3D; null) &#123;        bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try &#123;            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());        &#125; catch (BeanDefinitionStoreException var5) &#123;            this.getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; + bdHolder.getBeanName() + &quot;&#39;&quot;, ele, var5);        &#125;        this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要分为四个步骤:</p><ol><li>解析标签得到BeanDefinitionHolder，这一步的BeanDefinitionHolder中已经存储了id、name等属性</li><li>如果bean标签的子标签中包含自定义标签，则会调用delegate的decorateBeanDefinitionIfRequired方法解析子标签</li><li>注册BeanDefinitionHolder</li><li>发出响应事件，通知监听器bean已经解析完成</li></ol><h4 id="解析bean标签的属性"><a href="#解析bean标签的属性" class="headerlink" title="解析bean标签的属性"></a>解析bean标签的属性</h4><p>解析bean标签的属性调用的是delegate的parseBeanDefinitionElement方法，其内部调用了parseBeanDefinitionElement方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123;    &#x2F;&#x2F;获取id属性String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);    &#x2F;&#x2F;获取name属性String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);    &#x2F;&#x2F;如果name属性不为空，则将每个name加入aliases数组中List&lt;String&gt; aliases &#x3D; new ArrayList&lt;&gt;();if (StringUtils.hasLength(nameAttr)) &#123;String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);aliases.addAll(Arrays.asList(nameArr));&#125;String beanName &#x3D; id;    &#x2F;&#x2F;没有id属性而有name属性时，将会使用第一个name作为这个bean的idif (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;beanName &#x3D; aliases.remove(0);if (logger.isTraceEnabled()) &#123;logger.trace(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +&quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);&#125;&#125;if (containingBean &#x3D;&#x3D; null) &#123;checkNameUniqueness(beanName, aliases, ele);&#125;    &#x2F;&#x2F;将bean标签解析为AbstractBeanDefinitionAbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);if (beanDefinition !&#x3D; null) &#123;      &#x2F;&#x2F;如果既没有id属性又没有name属性，那么按照默认的规则生成beanNameif (!StringUtils.hasText(beanName)) &#123;try &#123;if (containingBean !&#x3D; null) &#123;beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true);&#125;else &#123;beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);String beanClassName &#x3D; beanDefinition.getBeanClassName();if (beanClassName !&#x3D; null &amp;&amp;beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;aliases.add(beanClassName);&#125;&#125;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);&#125;&#125;catch (Exception ex) &#123;error(ex.getMessage(), ele);return null;&#125;&#125;String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);      &#x2F;&#x2F;将解析好的bean标签放入BeanDefinitionHolder中并返回return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);&#125;return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要逻辑为</p><ol><li>获取bean标签的id和name属性，如果id为空，name不为空，则会将name作为id(多个name取第一个)</li><li>解析其他属性，获得AbstractBeanDefinition</li><li>如果id和name属性都为空，则将使用默认规则生成bean的id</li><li>将id，name，beanDefinition封装到BeanDefinitionHolder中返回</li></ol><p>解析bean标签的属性大多在parseBeanDefinitionElement方法中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;this.parseState.push(new BeanEntry(beanName));String className &#x3D; null;   &#x2F;&#x2F;获取class属性if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;   &#x2F;&#x2F;获取parent属性String parent &#x3D; null;if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);&#125;try &#123;     &#x2F;&#x2F;根据class和parent构造beanDefinitionAbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);     &#x2F;&#x2F;解析bean默认的各种属性parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));     &#x2F;&#x2F;解析meta子标签parseMetaElements(ele, bd);     &#x2F;&#x2F;解析lookup-method子标签parseLookupOverrideSubElements(ele, bd.getMethodOverrides());     &#x2F;&#x2F;解析replaced-method子标签parseReplacedMethodSubElements(ele, bd.getMethodOverrides());     &#x2F;&#x2F;解析constructor子标签parseConstructorArgElements(ele, bd);     &#x2F;&#x2F;解析property子标签parsePropertyElements(ele, bd);     &#x2F;&#x2F;解析qualifier子标签parseQualifierElements(ele, bd);bd.setResource(this.readerContext.getResource());bd.setSource(extractSource(ele));return bd;&#125;catch (ClassNotFoundException ex) &#123;error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);&#125;catch (NoClassDefFoundError err) &#123;error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);&#125;catch (Throwable ex) &#123;error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);&#125;finally &#123;this.parseState.pop();&#125;return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取BeanDefinitionHolder的逻辑主要有:</p><ol><li>获取class和parent属性，根据这两个属性构造BeanDefinition对象(实际是赋值给BeanDefinition对象的className属性和parent属性)</li><li>解析bean标签的各种属性(scope、lazy-init、autowired等)，放入BeanDefinition对应的属性中</li><li>解析mate子标签，放入BeanDefinitionHolder的属性中</li><li>解析lookup-method子标签，放入BeanDefinitionHolder的methodOverrides中</li><li>解析replace-method子标签，放入BeanDefinitionHolder的methodOverrides中</li><li>解析constructor子标签，放入BeanDefinitionHolder的属性中(指定index时，放入indexedArgumentValues中，未指定时，放入genericArgumentValues中)</li><li>解析property子标签，放入BeanDefinitionHolder的属性中</li><li>解析qulifier子标签，放入BeanDefinitionHolder的属性中<h4 id="bean标签自定义子标签的解析"><a href="#bean标签自定义子标签的解析" class="headerlink" title="bean标签自定义子标签的解析"></a>bean标签自定义子标签的解析</h4>解析子标签时，最终会调用BeanDefinitionParseDeletege的decorateIfRequired方法<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public BeanDefinitionHolder decorateIfRequired(Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) &#123;String namespaceUri &#x3D; getNamespaceURI(node);if (namespaceUri !&#x3D; null &amp;&amp; !isDefaultNamespace(namespaceUri)) &#123;NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);if (handler !&#x3D; null) &#123;BeanDefinitionHolder decorated &#x3D;handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));if (decorated !&#x3D; null) &#123;return decorated;&#125;&#125;else if (namespaceUri.startsWith(&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;&quot;)) &#123;error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);&#125;else &#123;&#x2F;&#x2F; A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.if (logger.isDebugEnabled()) &#123;logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);&#125;&#125;&#125;return originalDef;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>主要逻辑就是根据nameSpace找到对应的handler，然后解析自定义标签</li></ol><h4 id="注册BeanDefinitionHodler"><a href="#注册BeanDefinitionHodler" class="headerlink" title="注册BeanDefinitionHodler"></a>注册BeanDefinitionHodler</h4><p>向BeanDefinitionRegistry注册BeanDefinitionHolder时，会注册id和BeanDefinitionHolder的对应关系以及alias和BeanDefinitionHolder的对应关系</p><h4 id="通知监听器"><a href="#通知监听器" class="headerlink" title="通知监听器"></a>通知监听器</h4><p>如果配置了BeanDefinition的监听器，则会在BeanDefinitionHolder注册后被触发</p><h2 id="解析alias标签"><a href="#解析alias标签" class="headerlink" title="解析alias标签"></a>解析alias标签</h2><p>解析alias标签调用的是processAliasRegistratio方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void processAliasRegistration(Element ele) &#123;    String name &#x3D; ele.getAttribute(&quot;name&quot;);    String alias &#x3D; ele.getAttribute(&quot;alias&quot;);    boolean valid &#x3D; true;    if (!StringUtils.hasText(name)) &#123;        this.getReaderContext().error(&quot;Name must not be empty&quot;, ele);        valid &#x3D; false;    &#125;    if (!StringUtils.hasText(alias)) &#123;        this.getReaderContext().error(&quot;Alias must not be empty&quot;, ele);        valid &#x3D; false;    &#125;    if (valid) &#123;        try &#123;            this.getReaderContext().getRegistry().registerAlias(name, alias);        &#125; catch (Exception var6) &#123;            this.getReaderContext().error(&quot;Failed to register alias &#39;&quot; + alias + &quot;&#39; for bean with name &#39;&quot; + name + &quot;&#39;&quot;, ele, var6);        &#125;        this.getReaderContext().fireAliasRegistered(name, alias, this.extractSource(ele));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本逻辑就是获取name和alias标签，并将name和别名的对应关系注册到BeanDefinitionRegistry中</p><h2 id="解析import标签"><a href="#解析import标签" class="headerlink" title="解析import标签"></a>解析import标签</h2><p>解析import标签调用的是importBeanDefinitionResource方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void importBeanDefinitionResource(Element ele) &#123;    &#x2F;&#x2F;取出resource属性    String location &#x3D; ele.getAttribute(&quot;resource&quot;);    if (!StringUtils.hasText(location)) &#123;        this.getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);    &#125; else &#123;        location &#x3D; this.getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);        Set&lt;Resource&gt; actualResources &#x3D; new LinkedHashSet(4);        boolean absoluteLocation &#x3D; false;        try &#123;            &#x2F;&#x2F;判断是绝对属性还是相对属性            absoluteLocation &#x3D; ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();        &#125; catch (URISyntaxException var11) &#123;        &#125;        int importCount;        if (absoluteLocation) &#123;            try &#123;                &#x2F;&#x2F;调用loadBeanDefinitions读取resource指向的xml文件                importCount &#x3D; this.getReaderContext().getReader().loadBeanDefinitions(location, actualResources);                if (this.logger.isTraceEnabled()) &#123;                    this.logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);                &#125;            &#125; catch (BeanDefinitionStoreException var10) &#123;                this.getReaderContext().error(&quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, var10);            &#125;        &#125; else &#123;            try &#123;                Resource relativeResource &#x3D; this.getReaderContext().getResource().createRelative(location);                if (relativeResource.exists()) &#123;                    &#x2F;&#x2F;调用loadBeanDefinitions读取resource指向的xml文件                    importCount &#x3D; this.getReaderContext().getReader().loadBeanDefinitions(relativeResource);                    actualResources.add(relativeResource);                &#125; else &#123;                    String baseLocation &#x3D; this.getReaderContext().getResource().getURL().toString();                    importCount &#x3D; this.getReaderContext().getReader().loadBeanDefinitions(StringUtils.applyRelativePath(baseLocation, location), actualResources);                &#125;                if (this.logger.isTraceEnabled()) &#123;                    this.logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);                &#125;            &#125; catch (IOException var8) &#123;                this.getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, var8);            &#125; catch (BeanDefinitionStoreException var9) &#123;                this.getReaderContext().error(&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, var9);            &#125;        &#125;        Resource[] actResArray &#x3D; (Resource[])actualResources.toArray(new Resource[0]);        this.getReaderContext().fireImportProcessed(location, actResArray, this.extractSource(ele));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，对于import标签的解析，主要是获取了resource属性，然后获得的路径获取xml文件，并封装成Resource对象，再通过XmlBeanDefinitionReader来读取xml文件(读取过程如上一篇文章)</p><h2 id="解析beans标签"><a href="#解析beans标签" class="headerlink" title="解析beans标签"></a>解析beans标签</h2><p>对于beans标签的解析，只需要将beans标签当成root节点，再递归调用doRegisterBeanDefinitions方法即可</p>]]></content>
      
      
      <categories>
          
          <category> Spring源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析(一)</title>
      <link href="2021/07/25/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
      <url>2021/07/25/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>在开发Java项目的过程当中，适当地使用已有框架能够大大减少工作量。目前大部分Java项目都使用Spring对项目的类对象进行管理，本文主要探究Spring如何构造类对象，并对类对象的属性进行注入。</p><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>通常，我们使用Spring时，都会使用ApplicationContext作为容器，它有很多实现类，为了方便研究Spring，这里使用ClassPathXmlApplicationContext来举例</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(config);Object bean &#x3D; applicationContext.getBean(beanName);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面这行代码即可启动一个Spring项目，第二行的bean即为Spring管理的类对象(可以将类型强转成需要的类)。ClassPathXmlApplicationContext的构造方法如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123;this(new String[] &#123;configLocation&#125;, true, null);&#125; public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)throws BeansException &#123;super(parent);   &#x2F;&#x2F;设置xml配置文件位置setConfigLocations(configLocations);   &#x2F;&#x2F;启动Springif (refresh) &#123;refresh();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构造方法中，首先设置了配置文件的位置，然后启动Spring项目。setConfigLocations方法如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public void setConfigLocations(@Nullable String... locations) &#123;if (locations !&#x3D; null) &#123;Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);this.configLocations &#x3D; new String[locations.length];for (int i &#x3D; 0; i &lt; locations.length; i++) &#123;this.configLocations[i] &#x3D; resolvePath(locations[i]).trim();&#125;&#125;else &#123;this.configLocations &#x3D; null;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正启动Spring容器的是refresh方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public void refresh() throws BeansException, IllegalStateException &#123;synchronized (this.startupShutdownMonitor) &#123;     &#x2F;&#x2F;Spring5.3加入的StartupStep，用来记录Spring容器启动步骤中的一些指标StartupStep contextRefresh &#x3D; this.applicationStartup.start(&quot;spring.context.refresh&quot;);&#x2F;&#x2F;准备刷新上下文的环境prepareRefresh();&#x2F;&#x2F;初始化BeanFactory，并读取xmlConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();&#x2F;&#x2F;对BeanFactory进行一些增强prepareBeanFactory(beanFactory);try &#123;&#x2F;&#x2F;空实现，主要是为了让开发人员可以在context的子类中对beanFactory进行功能的增强postProcessBeanFactory(beanFactory);       &#x2F;&#x2F;同第一句StartupStep beanPostProcess &#x3D; this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);&#x2F;&#x2F;激活所有BeanFactory处理器invokeBeanFactoryPostProcessors(beanFactory);&#x2F;&#x2F;注册所有bean的处理器，这里只是注册，并不会实际调用postProcessBeforeInitialization和postProcessAfterInitialization方法registerBeanPostProcessors(beanFactory);beanPostProcess.end();&#x2F;&#x2F;初始化Message源，主要是为了国际化的处理initMessageSource();&#x2F;&#x2F;初始化消息广播器，广播器的beanName为applicationEventMulticasterinitApplicationEventMulticaster();&#x2F;&#x2F;空实现，可以在这里实现一些自定义的beanonRefresh();&#x2F;&#x2F;在注册的bean中查找消息监听者，并注册registerListeners();&#x2F;&#x2F;实例化所有非非懒加载的beanfinishBeanFactoryInitialization(beanFactory);&#x2F;&#x2F;完成refreshfinishRefresh();&#125;catch (BeansException ex) &#123;if (logger.isWarnEnabled()) &#123;logger.warn(&quot;Exception encountered during context initialization - &quot; +&quot;cancelling refresh attempt: &quot; + ex);&#125;&#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.destroyBeans();&#x2F;&#x2F; Reset &#39;active&#39; flag.cancelRefresh(ex);&#x2F;&#x2F; Propagate exception to caller.throw ex;&#125;finally &#123;&#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we&#x2F;&#x2F; might not ever need metadata for singleton beans anymore...resetCommonCaches();contextRefresh.end();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="环境参数验证"><a href="#环境参数验证" class="headerlink" title="环境参数验证"></a>环境参数验证</h4><p>Spring容器初始化的过程中，第一步就是准备刷新的上下文环境，其实现为:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void prepareRefresh() &#123;this.startupDate &#x3D; System.currentTimeMillis();this.closed.set(false);this.active.set(true);if (logger.isDebugEnabled()) &#123;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Refreshing &quot; + this);&#125;else &#123;logger.debug(&quot;Refreshing &quot; + getDisplayName());&#125;&#125;   &#x2F;&#x2F;空实现，在这一步可以添加对一些自定义的环境参数的验证initPropertySources();  &#x2F;&#x2F;验证必要的环境参数getEnvironment().validateRequiredProperties();if (this.earlyApplicationListeners &#x3D;&#x3D; null) &#123;this.earlyApplicationListeners &#x3D; new LinkedHashSet&lt;&gt;(this.applicationListeners);&#125;else &#123;this.applicationListeners.clear();this.applicationListeners.addAll(this.earlyApplicationListeners);&#125;this.earlyApplicationEvents &#x3D; new LinkedHashSet&lt;&gt;();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法主要就是对环境参数进行了验证。</p><h4 id="获取BeanFactory"><a href="#获取BeanFactory" class="headerlink" title="获取BeanFactory"></a>获取BeanFactory</h4><p>ApplicationContext是对BeanFactory功能的增强，因此也少不了获取BeanFactory这一步，其主要是通过obtainFreshBeanFactory方法来实现的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;refreshBeanFactory();return getBeanFactory();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中refreshBeanFactory方法是在AbstractRefreshableApplicationContext中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected final void refreshBeanFactory() throws BeansException &#123;   &#x2F;&#x2F;如果存在BeanFactoryif (hasBeanFactory()) &#123;     &#x2F;&#x2F;摧毁所有已注册的beandestroyBeans();     &#x2F;&#x2F;关闭已存在的BeanFactorycloseBeanFactory();&#125;try &#123;     &#x2F;&#x2F;创建BeanFactoryDefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();     &#x2F;&#x2F;设置serializationIdbeanFactory.setSerializationId(getId());     &#x2F;&#x2F;定制化BeanFactorycustomizeBeanFactory(beanFactory);     &#x2F;&#x2F;加载xml中的Bean定义loadBeanDefinitions(beanFactory);this.beanFactory &#x3D; beanFactory;&#125;catch (IOException ex) &#123;throw new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName(), ex);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取BeanFactory的逻辑还是很清晰的，如果有BeanFactory，则摧毁已经加载的Bean和BeanFactory；然后新建BeanFactory并设置serializationId，方便序列化；在定制化BeanFactory中，实际上是给两个参数赋值</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;if (this.allowBeanDefinitionOverriding !&#x3D; null) &#123;beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);&#125;if (this.allowCircularReferences !&#x3D; null) &#123;beanFactory.setAllowCircularReferences(this.allowCircularReferences);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，allowBeanDefinitionOverriding代表是否允许覆盖同名称的bean，allowCircularReferences代表是否允许循环依赖，这两个属性就可以在上面prepareRefresh方法中的initPropertySources中进行复制(子类重写方法)</p><h4 id="加载xml中的Bean定义"><a href="#加载xml中的Bean定义" class="headerlink" title="加载xml中的Bean定义"></a>加载xml中的Bean定义</h4><p>在refreshBeanFactory方法中，最重要的就是加载xml中的Bean定义(loadBeanDefinitions)，这个方法的实现在AbstractXmlApplicationContext中:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;&#x2F;&#x2F;创建读取xml定义的readerXmlBeanDefinitionReader beanDefinitionReader &#x3D; new XmlBeanDefinitionReader(beanFactory);&#x2F;&#x2F;设置环境参数以及资源加载器beanDefinitionReader.setEnvironment(this.getEnvironment());beanDefinitionReader.setResourceLoader(this);   &#x2F;&#x2F;EntityResolver是用来确定如何解析xml文件(DTD模式或者XSD模式)beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));&#x2F;&#x2F;初始化reader，在这一步可以重写子类方法，来对reader的功能进行增强initBeanDefinitionReader(beanDefinitionReader);   &#x2F;&#x2F;读取bean定义loadBeanDefinitions(beanDefinitionReader);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际读取bean定义的方法还在loadBeanDefinitions(注意这个入参是reader，上面方法的入参是BeanFactory)中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;Resource[] configResources &#x3D; getConfigResources();if (configResources !&#x3D; null) &#123;reader.loadBeanDefinitions(configResources);&#125;String[] configLocations &#x3D; getConfigLocations();if (configLocations !&#x3D; null) &#123;reader.loadBeanDefinitions(configLocations);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的getConfigLocations获取的就是在ClassPathXmlApplicationContext构造方法里调用setConfigLocations方法设置的配置文件的location，继续查看reader的loadBeanDefinitions方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123;Assert.notNull(locations, &quot;Location array must not be null&quot;);int count &#x3D; 0;for (String location : locations) &#123;count +&#x3D; loadBeanDefinitions(location);&#125;return count;&#125; public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException &#123;return loadBeanDefinitions(location, null);&#125; public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;ResourceLoader resourceLoader &#x3D; getResourceLoader();if (resourceLoader &#x3D;&#x3D; null) &#123;throw new BeanDefinitionStoreException(&quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);&#125;if (resourceLoader instanceof ResourcePatternResolver) &#123;try &#123;Resource[] resources &#x3D; ((ResourcePatternResolver) resourceLoader).getResources(location);int count &#x3D; loadBeanDefinitions(resources);if (actualResources !&#x3D; null) &#123;Collections.addAll(actualResources, resources);&#125;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);&#125;return count;&#125;catch (IOException ex) &#123;throw new BeanDefinitionStoreException(&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);&#125;&#125;else &#123;Resource resource &#x3D; resourceLoader.getResource(location);int count &#x3D; loadBeanDefinitions(resource);if (actualResources !&#x3D; null) &#123;actualResources.add(resource);&#125;if (logger.isTraceEnabled()) &#123;logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);&#125;return count;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的逻辑主要是将location指向的配置文件封装成Resource，供Spring容器使用，然后调用loadBeanDefinitions(入参为封装后的resource)方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;      return this.loadBeanDefinitions(new EncodedResource(resource));  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在loadBeanDefinitions方法中最终调用的是doLoadBeanDefinitions方法，在doLoadBeanDefinitions方法中，有这样两句代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Document doc &#x3D; this.doLoadDocument(inputSource, resource);int count &#x3D; this.registerBeanDefinitions(doc, resource);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一句是根据resource获取Document文件，第二句则是注册bean定义</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;    BeanDefinitionDocumentReader documentReader &#x3D; this.createBeanDefinitionDocumentReader();    int countBefore &#x3D; this.getRegistry().getBeanDefinitionCount();    documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource));    return this.getRegistry().getBeanDefinitionCount() - countBefore;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册bean定义最终调用的方法为</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void doRegisterBeanDefinitions(Element root) &#123;    BeanDefinitionParserDelegate parent &#x3D; this.delegate;    this.delegate &#x3D; this.createDelegate(this.getReaderContext(), root, parent);    if (this.delegate.isDefaultNamespace(root)) &#123;        String profileSpec &#x3D; root.getAttribute(&quot;profile&quot;);        if (StringUtils.hasText(profileSpec)) &#123;            String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(profileSpec, &quot;,; &quot;);            if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;                if (this.logger.isDebugEnabled()) &#123;                    this.logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + this.getReaderContext().getResource());                &#125;                return;            &#125;        &#125;    &#125;    this.preProcessXml(root);    this.parseBeanDefinitions(root, this.delegate);    this.postProcessXml(root);    this.delegate &#x3D; parent;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，preProcessXml和postProcessXml都是空实现，可以在里面实现自定义的逻辑，真正进行bean标签的解析是parseBeanDefinitions方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;    if (delegate.isDefaultNamespace(root)) &#123;        NodeList nl &#x3D; root.getChildNodes();        for(int i &#x3D; 0; i &lt; nl.getLength(); ++i) &#123;            Node node &#x3D; nl.item(i);            if (node instanceof Element) &#123;                Element ele &#x3D; (Element)node;                if (delegate.isDefaultNamespace(ele)) &#123;                    this.parseDefaultElement(ele, delegate);                &#125; else &#123;                    delegate.parseCustomElement(ele);                &#125;            &#125;        &#125;    &#125; else &#123;        delegate.parseCustomElement(root);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零拷贝技术</title>
      <link href="2021/07/17/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
      <url>2021/07/17/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>零拷贝技术，如其名字说的一样，当用户线程操作磁盘文件时，不需要将磁盘文件的数据进行多次拷贝，这样能极大提升系统性能。通常来说，零拷贝技术分为mmap和sendfile两种方式。</p><h3 id="传统I-O"><a href="#传统I-O" class="headerlink" title="传统I/O"></a>传统I/O</h3><p>当用户线程通过传统I/O对磁盘文件进行操作时，操作步骤如下:<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/91948d20927593e661d994f650f1f7cde09f2215.png" alt="传统I/O"></p><ol><li>先从用户态切换到内核态，将磁盘文件数据从磁盘复制到内核空间的缓冲区，</li><li>再从内核态切换到用户态，将磁盘文件数据从内核空间缓冲区复制到用户进程的缓冲区</li></ol><h3 id="mmap技术"><a href="#mmap技术" class="headerlink" title="mmap技术"></a>mmap技术</h3><p>mmap指内存映射技术，通常用来进行文件I/O，用户进程操作文件时步骤如下:<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/09471f5193f268c599240e0e4f12303a45681ec9.png" alt="mmap"></p><ol><li>从用户态切换到内存态，将磁盘文件数据从磁盘中复制到内核空间的缓冲区</li><li>在用户缓存中建立虚拟内存地址，其映射的是内核空间中缓冲区的数据<br>使用内存映射技术的好处是，不需要在用户空间内再拷贝一份文件数据，减少文件数据对用户缓存的占用，并且由于使用的是虚拟内存地址，不同用户进程可以映射到同一块内存缓冲区。</li></ol><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>sendfile是Linux系统在2.1版本引入的函数，并在2.4版本进行了进一步的优化，主要为了解决网络I/O时数据的复制问题，其操作文件时步骤如下:<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/6a7ec6c0b4cb9d608b1584d4b78ef2dd16e2e9c1.png" alt="sendfile"></p><ol><li>从用户态切换到内核态，将磁盘文件从磁盘中复制到内核空间缓冲区</li><li>在Socket缓冲区中建立内核空间缓冲区的虚拟地址映射</li><li>从内核态切换到用户态，将Socket虚拟地址映射的文件数据复制到网卡中并发送出去</li></ol><h3 id="Java中的应用"><a href="#Java中的应用" class="headerlink" title="Java中的应用"></a>Java中的应用</h3><p>在Java中，NIO和RandomAccessFile均使用了mmap来对文件进行操作。下面是个使用RandomAccessFile的例子。</p><p>假设一个文件中有10亿个数字，这些数字都是0-99999之间的数字，并且每行都是一个数字，但是这些数字并没有顺序，写一个程序将这个文件中的数字进行升序排序。</p><p>因为Java中short类型的数据最大值为32768，小于99999，因此这些数字在Java程序需要使用int类型的数据进行存储。那么10亿个数字需要的存储空间为4*1000000000/1024/1024/1024=3.7GB，而程序运行过程中通常使用Integer来存储数字，实际需要的内存空间至少还要翻一倍。大部分机器的运行内存并没有这么大，因此使用传统I/O最终会出现内存溢出，那么这时可以使用RandomAccessFile来进行文件处理。</p><p>主要的逻辑分为以下几步：</p><ol><li>将源文件分为100个文件(根据情况可以变更)，每次从源文件中取出一千万个数字进行排序，然后写入到新文件中</li><li>构造一个数组，数组中的每个元素存储的是这100个文件和当前文件读取的数字(刚开始默认读取一行数组)，根据当前文件读取的数字进行升序排序，其中null排在最后（因为null代表文件读到末尾），取排序后的第一个元素，将读取到的数字写到结果文件中，然后读取这个元素中的文件的下一行并复制给当前元素读取的数字</li><li>循环进行第二步，直到数组第一个元素读取到的数组为null，此时得到的结果文件就是排好序的文件。<br>代码如下:<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.util.*;public class HugeFileSort &#123;    &#x2F;&#x2F;总的数据个数(10亿)    private static Integer TOTAL_NUMBER;    &#x2F;&#x2F;分割的文件个数    private static Integer SPLIT_NUMBER;    &#x2F;&#x2F;数组中的每个元素    static class FileHolder &#123;        private RandomAccessFile file;        private String data;        FileHolder(RandomAccessFile file) throws IOException &#123;            this.file &#x3D; file;            &#x2F;&#x2F;file操作数据的位置可能不在文件开头，这里置为文件开头            file.seek(0);            this.data &#x3D; file.readLine();        &#125;    &#125;    &#x2F;&#x2F;生成源文件    public static void wirteFile(String file) throws IOException &#123;        RandomAccessFile srcFile &#x3D; new RandomAccessFile(file, &quot;rw&quot;);        TOTAL_NUMBER &#x3D; 1000000000;        SPLIT_NUMBER &#x3D; 100;        Random random &#x3D; new Random();        for (int i &#x3D; 0; i &lt; TOTAL_NUMBER; i++)&#123;            int randomNum &#x3D; random.nextInt(100000);            srcFile.writeBytes(String.valueOf(randomNum) + System.lineSeparator());        &#125;        srcFile.close();    &#125;    &#x2F;&#x2F;切割源文件    public static List&lt;RandomAccessFile&gt; splitFile(String srcFile) throws IOException &#123;        Integer perFileHoldNum &#x3D; TOTAL_NUMBER&#x2F;SPLIT_NUMBER;        RandomAccessFile file &#x3D; new RandomAccessFile(srcFile,&quot;r&quot;);        List&lt;RandomAccessFile&gt; splitFileList &#x3D; new ArrayList&lt;&gt;(SPLIT_NUMBER);        List&lt;Integer&gt; dataList &#x3D; new ArrayList&lt;&gt;(perFileHoldNum);        String line;        int fileIndex &#x3D; 0;        while((line &#x3D; file.readLine()) !&#x3D; null)&#123;            dataList.add(Integer.valueOf(line));            &#x2F;&#x2F;达到上限后写入一个文件            if (dataList.size() &#x3D;&#x3D; perFileHoldNum)&#123;                dataList.sort(null);                RandomAccessFile splitFile &#x3D; new RandomAccessFile(&quot;.&#x2F;test&#x2F;splitFile_&quot; + fileIndex + &quot;.txt&quot;,&quot;rw&quot;);                for (Integer data : dataList)&#123;                    splitFile.writeBytes(data + System.lineSeparator());                &#125;                splitFileList.add(splitFile);                dataList.clear();                fileIndex++;            &#125;        &#125;        return splitFileList;    &#125;    &#x2F;&#x2F;对文件进行排序,最终结果存储在resultFile中    public static String mergeFile(List&lt;RandomAccessFile&gt; fileList) throws IOException &#123;        String resultFileName &#x3D; &quot;.&#x2F;test&#x2F;resultFile.txt&quot;;        if (Objects.isNull(fileList) || Objects.equals(fileList.size(), 0)) &#123;            return null;        &#125;        if (Objects.equals(fileList.size(), 1)) &#123;            RandomAccessFile resultFile &#x3D; reNameFile(fileList.get(0), resultFileName);            resultFile.close();            return resultFileName;        &#125;        List&lt;FileHolder&gt; fileHolderList &#x3D; new ArrayList&lt;&gt;();        for (RandomAccessFile file: fileList)&#123;            fileHolderList.add(new FileHolder(file));        &#125;        RandomAccessFile result &#x3D; new RandomAccessFile(resultFileName,&quot;rw&quot;);        String writeData;        do &#123;            Collections.sort(fileHolderList, (o1, o2) -&gt;&#123;                if (!isNotEmpty(o1.data)) &#123;                    return 1;                &#125;                if (!isNotEmpty(o2.data)) &#123;                    return -1;                &#125;                Integer firstNumber &#x3D; Integer.valueOf(o1.data);                Integer secondNumber &#x3D; Integer.valueOf(o2.data);                return firstNumber.compareTo(secondNumber);            &#125; );            FileHolder fileHolder &#x3D; fileHolderList.get(0);            writeData &#x3D; fileHolder.data;            if (isNotEmpty(writeData))&#123;                fileHolder.data &#x3D; fileHolder.file.readLine();                result.writeBytes(writeData + System.lineSeparator());            &#125;        &#125; while (isNotEmpty(writeData));        for (RandomAccessFile file: fileList)&#123;            file.close();        &#125;        result.close();        return resultFileName;    &#125;    &#x2F;&#x2F;A)    public static RandomAccessFile reNameFile(RandomAccessFile file,String newName) throws IOException &#123;        RandomAccessFile reNameFile &#x3D; new RandomAccessFile(newName,&quot;rw&quot;);        file.seek(0);        FileChannel srcFc &#x3D; file.getChannel();        FileChannel destFc &#x3D; reNameFile.getChannel();        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);        while(srcFc.read(buffer) !&#x3D; -1)&#123;            buffer.flip();            destFc.write(buffer);            buffer.clear();        &#125;        file.close();        return reNameFile;    &#125;    public static Boolean isNotEmpty(String str) &#123;        return str !&#x3D; null &amp;&amp; str.length() &gt; 0;    &#125;    &#x2F;&#x2F;测试(在项目根目录下新建test文件夹)    public static void main(String[] args) throws IOException &#123;        String fileName &#x3D; &quot;.&#x2F;test&#x2F;source.txt&quot;;        wirteFile(fileName);        mergeFile(splitFile(fileName));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>注1:在对文件进行合并的时候，也可以不构造数组而使用归并<br>注2:在代码A处，进行文件复制时使用了文件的NIO，通过把源文件Channel数据写入buffer，在目标文件Channel读取buffer来实现。在网上还流传着另一种方式，直接通过Channel的transferTo方法来复制文件<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">srcFc.transferTo(0 , srcFc.size(), destFc);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种方式对于大文件来说是不安全的，因为Channel的size是有上限的（大概是1.5G-2G），如果文件很大的话，文件只会被复制一部分。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock加锁和释放锁的过程</title>
      <link href="2021/07/10/ReentrantLock%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/10/ReentrantLock%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>ReentrantLock是Java中一个可重入锁，同一个线程可以多次获取这个锁，只需要在释放的时候再多次解锁即可。其内部使用AQS来进行加锁和解锁。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Sync sync;public ReentrantLock() &#123;    sync &#x3D; new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123;    sync &#x3D; fair ? new FairSync() : new NonfairSync();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock内部有一个Sync类型的变量（Sync继承了AQS类），ReentrantLock主要就是依靠Sync变量来进行加锁和解锁。<br>Sync又分为公平锁和非公平锁。当使用无参构造方法时，生成的时非公平锁；使用有参构造方法时，可以指定是公平锁还是非公平锁。</p><h3 id="AQS加锁的几个相关变量"><a href="#AQS加锁的几个相关变量" class="headerlink" title="AQS加锁的几个相关变量"></a>AQS加锁的几个相关变量</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;持有锁的线程加锁次数private volatile int state;&#x2F;&#x2F;等待队列头节点private transient volatile Node head;&#x2F;&#x2F;等待队列尾节点private transient volatile Node tail;&#x2F;&#x2F;当前占有锁的线程private transient Thread exclusiveOwnerThread;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，持有锁的线程会放在exclusiveOwnerThread中，线程加锁的次数会存在state中，而等待锁的线程则会放在等待队列中，等待队列是个双向队列。为了方便管理，双向链表的头节点是不包含任何线程信息，而尾节点会包含线程信息。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>当需要对ReentrantLock进行加锁时，会调用lock方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void lock() &#123;    sync.lock();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其内部调用了sync的lock方法，对于不同类型的锁，lock方法的处理也不一样</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void lock() &#123;  acquire(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>公平锁的lock方法直接调用了acquire方法，其实现是在AbstractQueuedSynchronizer类中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void acquire(int arg) &#123;  if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，会调用tryAcquire方法尝试获取锁，而公平锁的tryAcquire方法实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final boolean tryAcquire(int acquires) &#123;  &#x2F;&#x2F;获取当前线程  final Thread current &#x3D; Thread.currentThread();  &#x2F;&#x2F;获取state变量  int c &#x3D; getState();  &#x2F;&#x2F;state为0，说明没有线程持有当前锁  if (c &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F;如果当前等待队列中没有元素或者头节点的下一个节点是本线程，则会尝试获取锁，成功后将获取锁的线程改为当前线程    if (!hasQueuedPredecessors() &amp;&amp;      compareAndSetState(0, acquires)) &#123;      setExclusiveOwnerThread(current);      return true;    &#125;  &#125;  &#x2F;&#x2F;如果state不为0，则说明有线程持有锁，需要判断是否是当前线程持有锁，如果是，则将state加上本次加锁次数设为新的state  else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;    int nextc &#x3D; c + acquires;    &#x2F;&#x2F;加锁次数已达上限，抛出异常    if (nextc &lt; 0)        throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;  &#125;  return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程尝试获取锁时，或先获取state，state代表持有锁的线程的加锁次数。如果state为0，并且当前等待队列没有线程，则会尝试通过CAS修改state，修改成功则视为加锁成功；如果state不为0，则要判断当前线程是否持有锁，如果是的话，则修改state。</p><p>如果tryAcquire获取锁失败，则会调用addWaiter方法，将当前线程加入等待队列中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Node addWaiter(Node mode) &#123;  &#x2F;&#x2F;将本线程加入等待节点中  Node node &#x3D; new Node(Thread.currentThread(), mode);  Node pred &#x3D; tail;  if (pred !&#x3D; null) &#123;    &#x2F;&#x2F;如果为节点不为空，则将尾节点设为本节点，这一步可能失败    node.prev &#x3D; pred;    if (compareAndSetTail(pred, node)) &#123;      pred.next &#x3D; node;      return node;    &#125;  &#125;  &#x2F;&#x2F;如果尾节点为空，则要进行初始化  enq(node);  return node;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addWaiter方法会将当前线程加入等待队列的队尾，如果等待队列还未初始化，则会调用enq方法进行初始化；如果将当前线程设为尾节点失败，则会调用enq方法，通过自旋将当前线程设为尾节点。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Node enq(final Node node) &#123;  &#x2F;&#x2F;自旋  for (;;) &#123;    Node t &#x3D; tail;    if (t &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;尾节点为空时，新建头节点，并将尾节点指向头节点      if (compareAndSetHead(new Node()))        tail &#x3D; head;    &#125; else &#123;      &#x2F;&#x2F;尾节点不为空，则说明其他线程已经初始化或者第一次将当前线程设为尾节点失败，再次尝试将当前线程设为尾节点      node.prev &#x3D; t;      if (compareAndSetTail(t, node)) &#123;        t.next &#x3D; node;        return t;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将当前线程加入等待队列后，或调用acquireQueued方法再次尝试获取锁</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final boolean acquireQueued(final Node node, int arg) &#123;    boolean failed &#x3D; true;    try &#123;        boolean interrupted &#x3D; false;        for (;;) &#123;            &#x2F;&#x2F;获取当前节点的前一个节点，如果前一个节点是头节点，则尝试使用tryAcquire方法获取锁，成功则返回。通常是在等待队列中被唤醒后执行本段逻辑获取锁，获取锁后会将当前节点设为头节点(线程信息被清空，waitStatus被保存)            final Node p &#x3D; node.predecessor();            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);                p.next &#x3D; null;                failed &#x3D; false;                return interrupted;            &#125;            &#x2F;&#x2F;挂起当前线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted &#x3D; true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果获取锁失败，则会尝试挂起当前线程，判断是否可以挂起线程调用的是shouldParkAfterFailedAcquire方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static boolean shouldParkAfterFailedAcquire(Node pred,  Node node) &#123;    &#x2F;&#x2F;线程能挂起的条件是前驱节点的状态为SIGNAL    int ws &#x3D; pred.waitStatus;    &#x2F;&#x2F;前驱节点为SIGNAL则挂起    if (ws &#x3D;&#x3D; Node.SIGNAL)        return true;    if (ws &gt; 0) &#123;        &#x2F;&#x2F;前驱节点为CANCELLED，则一直向前找到SIGNAL的节点，设为前驱节点        do &#123;            node.prev &#x3D; pred &#x3D; pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next &#x3D; node;    &#125; else &#123;        &#x2F;&#x2F;前驱节点还未被设置状态，直接通过CAS设为SIGNAL(可能失败)        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    &#x2F;&#x2F;本次执行方法时前驱节点不为SIGNAL，返回false，让acquireQueued进入下一个循环判断是否可以安全挂起    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个节点的waitStatus状态包括以下几个状态</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int CANCELLED &#x3D;  1;static final int SIGNAL    &#x3D; -1;static final int CONDITION &#x3D; -2;static final int PROPAGATE &#x3D; -3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当前驱节点为SIGNAL时，表示本节点可以唤醒下一个节点。如果一个节点可以被挂起，则会调用parkAndCheckInterrupt方法挂起线程</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final boolean parkAndCheckInterrupt() &#123;  LockSupport.park(this);  return Thread.interrupted();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，对于公平锁来说，如果等待队列中没有线程，才会去获取锁；否则会将当前线程加入等待队列中，并将自己挂起。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void lock() &#123;  if (compareAndSetState(0, 1))    setExclusiveOwnerThread(Thread.currentThread());  else    acquire(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁进行加锁时，首先会竞争锁，竞争失败再调用acquire方法。acquire方法和公平锁一样，调用的都是AbstractQueuedSynchronizer的acquire方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final void acquire(int arg) &#123;  if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁的tryAcquire方法调用的是nonfairTryAcquire方法，这个方法的实现在Sync类中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final class NonfairSync extends Sync &#123;    private static final long serialVersionUID &#x3D; 7316153563782823691L;    protected final boolean tryAcquire(int acquires) &#123;        return nonfairTryAcquire(acquires);    &#125;&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123;    final boolean nonfairTryAcquire(int acquires) &#123;        final Thread current &#x3D; Thread.currentThread();        int c &#x3D; getState();        if (c &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F;不判断等待队列是否为空，直接竞争锁            if (compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;            int nextc &#x3D; c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非公平锁的tryAcquire方法和公平锁的tryAcquire方法大体相同，唯一不同的是非公平锁不管等待队列是否为空都会竞争锁。当进入等待队列后，公平锁和非公平锁几乎相同。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁调用的是ReentrantLock的unlock方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void unlock() &#123;    sync.release(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的release方法实现在AbstractQueuedSynchronizer中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h &#x3D; head;        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用tryRelease方法释放独占线程，其实现在Sync中</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected final boolean tryRelease(int releases) &#123;    int c &#x3D; getState() - releases;    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free &#x3D; false;    if (c &#x3D;&#x3D; 0) &#123;        free &#x3D; true;        setExclusiveOwnerThread(null);    &#125;    setState(c);    return free;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑也很简单，将state减去被释放的锁次数，如果state为0，则说明锁已经被释放，将当前占有锁的线程置为null。释放锁成功后，release方法会判断头节点是否为空，waitStatus是否不为0(通常来说，当等待队列第一个元素加入的时候，头节点的waitStatus在shouldParkAfterFailedAcquire方法中会被设为SIGNAL)，如果判断通过，会调用unparkSuccessor方法唤醒后续节点</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void unparkSuccessor(Node node) &#123;    int ws &#x3D; node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    Node s &#x3D; node.next;    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;        s &#x3D; null;        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)            if (t.waitStatus &lt;&#x3D; 0)                s &#x3D; t;    &#125;    if (s !&#x3D; null)        LockSupport.unpark(s.thread);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唤醒后续节点时，如果头节点的下一个节点waitStatus&gt;0，则说明该线程已经取消等待，会从队尾遍历到队头，找到第一个waitStatus小于0的节点，将其唤醒并获得锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的volatile关键字</title>
      <link href="2021/07/03/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/07/03/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Java中多线程环境下为了保证共享变量的可见性，通常会使用volatile关键字修饰该变量，但volatile关键字并不只保证可见性。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>不同于计算机的内存模型，JVM构建了一套简化的线程模型<br><img src="https://images2.imgbox.com/b0/05/arz8Brgk_o.jpg" alt="Java内存模型"><br>每条线程都会有自己单独的工作内存用来存储共享数据，每当线程要操作一个共享变量时，会首先将该变量从主内存加载到工作内存中，在工作内存中修改之后再刷回主内存中。所以在每个线程的工作内存中，同一个共享变量有可能有不同的值。</p><h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>被volatile关键字修饰的共享变量，在被线程获取后，会给共享变量加上Lock锁，阻止其他线程对该变量进行读写，在线程把共享变量从工作内存刷回主内存后会释放Lock锁，这时其他线程才可以获取到这个变量，因此volatile可以保证变量的可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在同一条语句中，volatile关键字可以禁止指令重排。在单例模式的double check写法中，如果不给变量加volatile关键字，就有可能出现空指针异常</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SingletonObject &#123;    private static Object object;    public static Object getSingleton()&#123;        &#x2F;&#x2F;A)        if (Objects.isNull(object))&#123;            synchronized (SingletonObject.class)&#123;                if (Objects.isNull(object))&#123;                    &#x2F;&#x2F;B）可能发生指令重排                    object &#x3D; new Object();                &#125;            &#125;        &#125;        return object;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在代码B处，实际有三个指令:1.在堆内存中开辟一块空间给Object，2.将object指向该空间，3.执行Object的init方法。其中第二步和第三步并没有先后顺序，有可能会发生指令重排，先执行第二步，然后执行第三步，在执行第三步之前Objects.isnull(object)返回的是false，因为object已经指向了堆内存中的一块空间,如果其他线程在第二步后执行到代码A处，则会返回一个没有执行init方法的对象，使用这个对象会报空指针异常。<br>但是如果给object变量加上volatile关键字，则能禁止代码B处的指令重排，因此volatile关键字可以保证变量操作的有序性</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static volatile Object object;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>在多线程环境下，一系列的操作要么同时成功，要么同时失败，则可以称这一系列的操作有原子性(不可分割)。volatile明显不能保证这种操作。当然也有例外，在32位操作系统的JVM中，CPU对于long和double类型的变量操作实际是分为两步来进行的，因为CPU一次只能操作32位数据，而long和double类型的变量有64位，此时对变量添加volatile关键字能保证变量操作的原子性。</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>volatile在操作系统底层实际依靠MESI协议来保证变量操作的可见性，MESI代表变量的四种状态</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>M(Modified)</td><td>变量有效，但是已经被修改，和主内存中的数据不一致</td></tr><tr><td>E(Exclusive)</td><td>变量有效，数据只存在本缓存行中，和主内存中的数据一致</td></tr><tr><td>S(Shared)</td><td>变量有效，数据存在很多缓存行中，和主内存中的数据一致</td></tr><tr><td>I(Invalid)</td><td>变量无效</td></tr></tbody></table><p>当多核硬件系统操作数据时，大致流程如下:<br>1.两个CPU通过总线将主内存中的变量a加载到各自的高速缓存中，此时两个CPU中的变量a都是共享(S)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/04e64e2360fb9b2c3826e876c8df6da460a78f75.png"></p><p>2.当CPU1要对a变量进行修改时，会先向总线发送请求，要求对a变量进行修改，总线会通知CUP2，将a变量置为无效(I)；待CPU2将a置为无效后通知总线，总线通知CPU1，CPU1修改a后，将a状态置为已修改(M)<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/adbb81abe53d980adf78cefc83c4d7e39aed357c.png"></p><p>3.CPU1通过总线将a刷回主内存，并将自己缓存区内的a置为独占(E)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/2428bb14748e254e5fc6327de77fa0b6fc07b64f.png"></p><p>4.当CPU2要使用a变量时，发现自己缓存区中的a为无效(I)状态，通过总线从主内存中读取a，此时CPU1和CPU2中的a都变为共享(S)状态<br><img src="https://images.weserv.nl/?url=https://i0.hdslb.com/bfs/album/04e64e2360fb9b2c3826e876c8df6da460a78f75.png"></p><h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p>当大量被volatile的变量频繁进行修改或者有大量CAS操作频繁进行(也可能两者都有)，总线的流量激增，此时会造成总线风暴，总线的数据处理能力会大大降低。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor源码解析</title>
      <link href="2021/06/26/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/26/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>在服务器中，为了减少频繁创建线程给系统带来的不必要开销，当需要使用线程时，通常会采用线程池的方式。不同系统中的线程池实现方式不同，在JDK1.8中，线程池使用线程+等待队列的方式实现。</p><p>###主要成员变量及其含义</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;ctl中，高三位存储的是线程池当前的状态，低29位存储的是线程池中线程个数(默认为RUNNING状态，线程个数为0，这里说的低29位只适用于Integer最大为2^32的系统)private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));&#x2F;&#x2F;ctl中低多少位用来保存线程数，通常来说是29private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;&#x2F;&#x2F;线程池能容纳的最大线程数，低29位都为1（低多少位为1取决于系统中Integer的最大值）private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;&#x2F;&#x2F;线程池处于运行状态private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于shutdown状态（此时线程池中仍在执行的任务不会被中止，但不接受新任务），调用shutdown方法后由RUNNING变为SHUTDOWNprivate static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于stop状态（此时线程池不接受新任务，清空任务队列，并会尝试中断所有活跃线程），调用shutdownNow方法后由RUNNING或SHUTDOWN变为STOPprivate static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池处于tidying状态（此时线程池中，活跃线程变为0且任务队列中没有任务），SHUTDOWN或STOP状态下处理完所有任务则变为TIDYINGprivate static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;线程池彻底终止，TIDYING状态下调用terminated方法后变为TERMINATEDprivate static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;&#x2F;&#x2F;计算线程状态private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;&#x2F;&#x2F;计算当前线程池中活跃线程数量private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;&#x2F;&#x2F;计算ctl值private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;&#x2F;&#x2F;线程池所使用的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;&#x2F;&#x2F;线程池中包含所有线程的工作队列private final HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;();&#x2F;&#x2F;核心线程数private volatile int corePoolSize;&#x2F;&#x2F;最大线程数private volatile int maximumPoolSize;&#x2F;&#x2F;线程被回收前最大的闲置时间private volatile long keepAliveTime;&#x2F;&#x2F;拒绝策略private volatile RejectedExecutionHandler handler;&#x2F;&#x2F;创建线程使用的线程工厂private volatile ThreadFactory threadFactory;&#x2F;&#x2F;默认拒绝策略（拒绝任务并抛出异常）private static final RejectedExecutionHandler defaultHandler &#x3D;        new AbortPolicy();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) &#123;    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;&#x3D; 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)        throw new NullPointerException();    this.corePoolSize &#x3D; corePoolSize;    this.maximumPoolSize &#x3D; maximumPoolSize;    this.workQueue &#x3D; workQueue;    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);    this.threadFactory &#x3D; threadFactory;    this.handler &#x3D; handler;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的构造函数都会指向这个构造方法，这个构造方法的入参含义依次为核心线程数，最大线程数，空闲时间，空闲时间单位，阻塞队列，线程工厂，拒绝策略</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>提交任务通常使用submit方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Future&lt;?&gt; submit(Runnable task) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);  execute(ftask);  return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);  execute(ftask);  return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;  if (task &#x3D;&#x3D; null) throw new NullPointerException();  RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);  execute(ftask);  return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;  return new FutureTask&lt;T&gt;(callable);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>submit方法中首先将入参包装成FutureTask类，然后执行execute方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void execute(Runnable command) &#123;  if (command &#x3D;&#x3D; null)    throw new NullPointerException();  int c &#x3D; ctl.get();  if (workerCountOf(c) &lt; corePoolSize) &#123;    if (addWorker(command, true))      return;    c &#x3D; ctl.get();  &#125;  if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;    int recheck &#x3D; ctl.get();    if (! isRunning(recheck) &amp;&amp; remove(command))      reject(command);    else if (workerCountOf(recheck) &#x3D;&#x3D; 0)      addWorker(null, false);  &#125;  else if (!addWorker(command, false))    reject(command);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>execute方法的逻辑分为三步：</p><ol><li>判断工作线程数是否大于核心线程数，如果小于，则尝试新开一个线程执行该任务(不保证添加线程成功)</li><li>如果工作线程数大于核心线程数并且线程池处于运行状态，则将任务加入阻塞队列中，之后继续判断线程是否处于运行状态，如果不处于运行状态，则尝试移除该任务，移除任务成功则根据拒绝策略执行拒绝逻辑；移除任务失败，则判断工作线程是否为0，为0的话添加一条非核心线程处理任务。</li><li>如果工作线程数大于核心线程数但线程池不处于运行中状态或者处于运行中状态但队列已满，则尝试添加线程执行该任务，如果失败，则执行决绝策略。（非核心线程就是在这一步加入线程池中的）</li></ol><p>实际添加线程的逻辑在addWorker方法中，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private boolean addWorker(Runnable firstTask, boolean core) &#123;      retry:      for (;;) &#123;          int c &#x3D; ctl.get();          &#x2F;&#x2F;获取线程池当前状态          int rs &#x3D; runStateOf(c);          &#x2F;&#x2F;如果线程池处于SHUTDOWN之后的状态或者处于SHUTDOWN状态，但想新建线程，则直接返回false          if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;              ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;                 firstTask &#x3D;&#x3D; null &amp;&amp;                 ! workQueue.isEmpty()))              return false;          &#x2F;&#x2F;自旋，直到更改ctl中的线程数成功；如果自旋过程中发现线程池已达最大容量，则返回false          for (;;) &#123;              int wc &#x3D; workerCountOf(c);              if (wc &gt;&#x3D; CAPACITY ||                  wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))                  return false;              if (compareAndIncrementWorkerCount(c))                  break retry;              c &#x3D; ctl.get();              if (runStateOf(c) !&#x3D; rs)                  continue retry;          &#125;      &#125;      boolean workerStarted &#x3D; false;      boolean workerAdded &#x3D; false;      Worker w &#x3D; null;      try &#123;          &#x2F;&#x2F;新建worker          w &#x3D; new Worker(firstTask);          final Thread t &#x3D; w.thread;          if (t !&#x3D; null) &#123;              &#x2F;&#x2F;新增worker时加锁              final ReentrantLock mainLock &#x3D; this.mainLock;              mainLock.lock();              try &#123;                  int rs &#x3D; runStateOf(ctl.get());                  &#x2F;&#x2F;再次检查线程池状态，如果状态不对则抛出异常，进入finally解锁                  if (rs &lt; SHUTDOWN ||                      (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;                      if (t.isAlive())                          throw new IllegalThreadStateException();                      &#x2F;&#x2F;添加任务                      workers.add(w);                      int s &#x3D; workers.size();                      if (s &gt; largestPoolSize)                          largestPoolSize &#x3D; s;                      workerAdded &#x3D; true;                  &#125;              &#125; finally &#123;                  mainLock.unlock();              &#125;              &#x2F;&#x2F;添加worker成功以后，调用start方法启动worker              if (workerAdded) &#123;                  t.start();                  workerStarted &#x3D; true;              &#125;          &#125;      &#125; finally &#123;          &#x2F;&#x2F;添加任务失败          if (! workerStarted)              addWorkerFailed(w);      &#125;      return workerStarted;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在线程池中，实际执行任务调用的是Worker类，Worker类继承了AQS，并实现了Runnable接口，其构造方法为:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Worker(Runnable firstTask) &#123;  setState(-1);  this.firstTask &#x3D; firstTask;  this.thread &#x3D; getThreadFactory().newThread(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker是个不可重入的锁，并且Worker的Thread调用start方法时，执行的任务为自己，Worker的run方法如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void run() &#123;  runWorker(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中runWorker方法为ThreadPoolExecutor的方法，其实现为:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void runWorker(Worker w) &#123;    Thread wt &#x3D; Thread.currentThread();    Runnable task &#x3D; w.firstTask;    w.firstTask &#x3D; null;    &#x2F;&#x2F;首先对worker解锁，因为刚构造worker时，worker的state为-1    w.unlock();    boolean completedAbruptly &#x3D; true;    try &#123;        &#x2F;&#x2F;循环获取任务        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;            &#x2F;&#x2F;获取任务成功则对worker进行加锁，确保worker同时只会执行一个任务            w.lock();            &#x2F;&#x2F;处于STOP状态时，需要worker中的线程打上中止标，但不会影响线程正在执行的任务            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try &#123;                &#x2F;&#x2F;空实现，可继承ThreadPoolExecutor并重写该方法，在任务执行前对线程和任务进行处理                beforeExecute(wt, task);                Throwable thrown &#x3D; null;                try &#123;                    &#x2F;&#x2F;直接调用run方法                    task.run();                &#125; catch (RuntimeException x) &#123;                    thrown &#x3D; x; throw x;                &#125; catch (Error x) &#123;                    thrown &#x3D; x; throw x;                &#125; catch (Throwable x) &#123;                    thrown &#x3D; x; throw new Error(x);                &#125; finally &#123;                    &#x2F;&#x2F;空实现，可继承ThreadPoolExecutor并重写该方法，在任务执行后对线程和任务进行处理                    afterExecute(task, thrown);                &#125;            &#125; finally &#123;                &#x2F;&#x2F;执行完一次任务后，解锁worker                task &#x3D; null;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly &#x3D; false;    &#125; finally &#123;        &#x2F;&#x2F;当Worker执行完所有任务，并且取不到新的任务时，调用该方法        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>runWorker方法的逻辑非常简单，首先获取任务（新建时自带任务或者从阻塞队列中获取），获取成功则执行任务。从阻塞队列中获取任务时，调用的时getTask方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private Runnable getTask() &#123;  boolean timedOut &#x3D; false;  &#x2F;&#x2F;自旋获取任务  for (;;) &#123;      int c &#x3D; ctl.get();      int rs &#x3D; runStateOf(c);      &#x2F;&#x2F;判断线程池状态是否正确，不正确则返回null      if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;          decrementWorkerCount();          return null;      &#125;      int wc &#x3D; workerCountOf(c);      &#x2F;&#x2F;判断阻塞队列取任务时是否进行超时判断      boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;      &#x2F;&#x2F;如果线程池已达最大容量或者非核心线程获取任务超时，并且工作线程不为空阻塞队列为空，则返回null      if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))          &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;          if (compareAndDecrementWorkerCount(c))              return null;          continue;      &#125;      try &#123;          &#x2F;&#x2F;如果线程数小于核心线程数，则使用take方法阻塞核心线程；否则调用poll方法，并设置超时时间，如果过了超时时间还没有取到任务，则返回          Runnable r &#x3D; timed ?              workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :              workQueue.take();          if (r !&#x3D; null)              return r;          timedOut &#x3D; true;      &#125; catch (InterruptedException retry) &#123;          timedOut &#x3D; false;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，对于非核心线程，如果在有效存活时间内取不到任务，则会直接返回null，导致runWorker中跳出循环，并销毁线程。</p><p>从上面的代码可以看出，当向线程池submit一个任务时，会优先添加核心线程处理任务，如果核心线程已满，则优先加入阻塞队列中，如果阻塞队列也放不下，则会新建线程（带超时时间）处理任务；如果到达线程池最大线程数，则会执行拒绝策略。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池有四种拒绝策略：</p><ol><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常</li><li>DiscardPolicy：丢弃提交的任务，并且不抛出异常</li><li>DiscardOldestPolicy：丢弃阻塞队列中头部的任务，重新提交被拒绝的任务</li><li>CallerRunsPolicy：由调用线程执行任务</li></ol><h3 id="tomcat线程池"><a href="#tomcat线程池" class="headerlink" title="tomcat线程池"></a>tomcat线程池</h3><p>tomcat线程池的核心类为StandardThreadExecutor，其内部构造了一个org.apache.tomcat.util.threads.ThreadPoolExecutor类（继承自JDK的ThreadPoolExecutor），并且使用了tomcat自定义的任务队列TaskQueue。<br>在TaskQueue的offer方法中，如果新增任务时，无空闲线程并且tomcat的线程数小于最大线程数，则会返回false</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public boolean offer(Runnable o) &#123;    if (parent&#x3D;&#x3D;null) return super.offer(o);    if (parent.getPoolSize() &#x3D;&#x3D; parent.getMaximumPoolSize()) return super.offer(o);    if (parent.getSubmittedCount()&lt;&#x3D;(parent.getPoolSize())) return super.offer(o);    if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) return false;    return super.offer(o);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于org.apache.tomcat.util.threads.ThreadPoolExecutor的execute方法与JDK中的逻辑一样，因此在进行</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (isRunning(c) &amp;&amp; workQueue.offer(command))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>判断时，workQueue.offer会返回false，也就是说，向tomcat中的线程池中添加任务，若核心线程已满，会优先新建非核心线程执行任务，等到达最大线程容量的时候才向等待队列中插入任务。<br>JDK和tomcat的线程池对于核心线程已满的情况下，新增任务的处理逻辑不同是因为JDK中的线程池处理的任务是CPU密集型任务，对新建线程消耗的资源更敏感；而tomcat作为服务器，处理的大部分是IO密集型任务，对于新建线程消耗的资源没有那么敏感，并且优先新建线程处理任务也能提高服务器的响应能力。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> ThreadPoolExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解析</title>
      <link href="2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>JDK1.8版本的ConcurrentHashMap与JDK1.7采用了不同的实现。不同于JDK1.7中segment+哈希桶数组，JDK1.8使用的数据结构为一个哈希桶数组，同时由于1.8中CAS的支持，在1.8中使用CAS+synchronize锁来实现线程安全。</p><h3 id="主要成员变量及其含义"><a href="#主要成员变量及其含义" class="headerlink" title="主要成员变量及其含义"></a>主要成员变量及其含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;数组最大长度private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;数组默认长度private static final int DEFAULT_CAPACITY &#x3D; 16;&#x2F;&#x2F;默认并发数，在JDK1.7中用来指定segment的默认个数，在1.8中基本已不再使用private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;&#x2F;&#x2F;负载因子private static final float LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表节点数超过8个时转换为红黑树static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;红黑树节点数少于6个时退化为链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;哈希桶数组长度小于64时，链表节点数超过8个，哈希桶数组会优先扩容而不是将链表转化为红黑树static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组扩容时，每个线程负责迁移的节点个数的最小步长private static final int MIN_TRANSFER_STRIDE &#x3D; 16;&#x2F;&#x2F;sizeCtl中用来存储扩容线程个数信息的二进制位数（低16位）private static int RESIZE_STAMP_BITS &#x3D; 16;&#x2F;&#x2F;数组扩容时，最多允许的线程数private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;&#x2F;&#x2F;sizeCtl中用来存储数组大小信息的二进制位数（高16位）private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;&#x2F;&#x2F;哈希桶数组transient volatile Node&lt;K,V&gt;[] table;&#x2F;&#x2F;扩容过程中新的哈希桶数组private transient volatile Node&lt;K,V&gt;[] nextTable;&#x2F;&#x2F;基础数组长度（实际数组长度可能比这个值大）private transient volatile long baseCount;&#x2F;&#x2F;值为-1时代表正在初始化，其他负数代表数组正在进行扩容，扩容时高16位与哈希桶数组大小有关，低16位为扩容的线程数+1;当sizeCtl大于0时，则表示当前哈希桶数组所能容纳的最大元素个数（0.75*数组长度）private transient volatile int sizeCtl;&#x2F;&#x2F;数组扩容时还未被分配扩容线程的最大indexprivate transient volatile int transferIndex;&#x2F;&#x2F;扩容时，CounterCell数组的锁private transient volatile int cellsBusy;&#x2F;&#x2F;扩容时，如果baseCount并发量太高，则将要增加的数组长度放到这个数组中（一般来说，数组长度为baseCount和这个数组中所有元素之和）private transient volatile CounterCell[] counterCells;&#x2F;&#x2F;节点正在被移动时，头节点的hash值static final int MOVED     &#x3D; -1;&#x2F;&#x2F;树形节点根节点的hash值static final int TREEBIN   &#x3D; -2;&#x2F;&#x2F;使用computeIfAbsent方法时，节点的hash值static final int RESERVED  &#x3D; -3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存节点的哈希桶数组使用transient关键字修饰，其目的与HashMap一致，都是因为在同一个对象在不同虚拟机中的hashCode可能不一致，因此对ConcurrentHashMap序列化时只序列化每个节点，反序列化时取出每个节点重新构建哈希桶数组。</p><p>###构造函数<br>####无参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无参构造函数只是一个空实现，没有进行任何处理<br>####有参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap(int initialCapacity,                       float loadFactor, int concurrencyLevel) &#123;  if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)    throw new IllegalArgumentException();  if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins    initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads  long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);  int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : tableSizeFor((int)size);  this.sizeCtl &#x3D; cap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中，根据给定的入参计算出数组初始长度（2^n），并将其赋值给sizeCtl，其中，tableSizeFor函数的实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static final int tableSizeFor(int c) &#123;  int n &#x3D; c - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过位运算，保证数组长度必定位2^n</p><p>###添加元素<br>添加元素使用的是put方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(key, value, false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>内部直接调用了putVal方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;  if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();  &#x2F;&#x2F;计算hash值  int hash &#x3D; spread(key.hashCode());  int binCount &#x3D; 0;  for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;    Node&lt;K,V&gt; f; int n, i, fh;    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;如果哈希桶数组未初始化，则先初始化哈希桶数组      tab &#x3D; initTable();    else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;如果要添加的元素所在的数组位置为空，则直接使用cas操作将元素添加进去，成功则跳出循环      if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))        break;    &#125;    else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)      &#x2F;&#x2F;如果添加的元素所在数组位置头节点被移动了，说明正在进行数组扩容，则当前线程也帮忙进行扩容      tab &#x3D; helpTransfer(tab, f);    else &#123;      V oldVal &#x3D; null;      &#x2F;&#x2F;根据数组位置寻找头节点，然后进行插入，这里对头节点进行加锁并比较，是为了防止代码运行到这里时，扩容和插入同时进行      synchronized (f) &#123;        if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;          if (fh &gt;&#x3D; 0) &#123;            binCount &#x3D; 1;            &#x2F;&#x2F;遍历链表，如果找到key相等且equals方法为true的节点，则修改并返回旧值，否则插入并返回null            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;              K ek;              if (e.hash &#x3D;&#x3D; hash &amp;&amp;                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;                oldVal &#x3D; e.val;                if (!onlyIfAbsent)                    e.val &#x3D; value;                break;              &#125;              Node&lt;K,V&gt; pred &#x3D; e;              if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,value, null);                break;              &#125;            &#125;          &#125;          else if (f instanceof TreeBin) &#123;            &#x2F;&#x2F;如果是树节点，则使用树节点的putVal方法            Node&lt;K,V&gt; p;            binCount &#x3D; 2;            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) !&#x3D; null) &#123;              oldVal &#x3D; p.val;              if (!onlyIfAbsent)                  p.val &#x3D; value;            &#125;          &#125;        &#125;      &#125;      if (binCount !&#x3D; 0) &#123;        &#x2F;&#x2F;插入成功后，判断是否需要将链表变为红黑树        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)          treeifyBin(tab, i);        if (oldVal !&#x3D; null)          return oldVal;        break;      &#125;    &#125;  &#125;  &#x2F;&#x2F;将ConcurrentHashMap的size加一  addCount(1L, binCount);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal方法的执行逻辑为：</p><ol><li>调用spread方法计算插入节点的hash值</li><li>判断哈希桶数组是否为空，如果为空，则先调用initTable方法初始化数组，进入下一次循环</li><li>如果不为空，则找到插入节点所在的数组位置，如果该位置为空，则使用cas操作将要插入的节点放在数组该位置并跳出循环</li><li>如果该位置不为空，则对该位置进行加锁。加锁失败进入下一个循环，加锁成功则先比较数组该位置头节点在加锁前后是否改变，如果改变了，则说明当前在进行扩容，进入下一次循环</li><li>如果没有改变，说明只有当前线程在操作链表（红黑树），先查看头节点哈希值是否大于等于0（树形节点哈希值小于0），如果大于等于0，则数组该位置说明为链表，遍历链表，如果key已经存在，则替换value值，否则在链表结尾添加新节点</li><li>如果头节点的哈希值小于0，则判断是否为树形节点，如果是的话，调用树形节点的putTreeVal方法</li><li>添加元素结束后，调用addCount方法将ConcurrentHashMap的size加一</li></ol><p>如果哈希桶数组未初始化，则会先调用initTable方法进行数组的初始化，其实现如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Node&lt;K,V&gt;[] initTable() &#123;  Node&lt;K,V&gt;[] tab; int sc;  &#x2F;&#x2F;如果一次循环结束哈希桶数组还未初始化，则再次进入循环  while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F;如果sizeCtl小于0，则说明数组正在进行初始化或者正在扩容，让出线程的时间片，进行自旋    if ((sc &#x3D; sizeCtl) &lt; 0)      Thread.yield();    else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;      &#x2F;&#x2F;如果通过cas操作将sc置为-1成功，则说明获得了初始化线程的锁，开始初始化线程      try &#123;        &#x2F;&#x2F;再次判断哈希桶数组是否未初始化，防止其他线程初始化并放入元素后（此时sc&gt;0），本线程获得锁，然后重新将哈希桶数组初始化        if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;          &#x2F;&#x2F;如果sc大于0，则说明ConcurrentHashMap是通过有参构造生成的，此时sc即为数组大小，否则，说明ConcurrentHashMap是通过无参构造生成的，直接使用默认数组大小          int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];          table &#x3D; tab &#x3D; nt;          &#x2F;&#x2F;sc等于0.75n，          sc &#x3D; n - (n &gt;&gt;&gt; 2);        &#125;      &#125; finally &#123;        &#x2F;&#x2F;假如数组初始化后通过cas操作将sizeCtl置为-1，但实际未通过try中的if判断，则需要将sizeCtl改为原来的值；如果进入了if判断，则将sizeCtl改为数组长度的0.75倍        sizeCtl &#x3D; sc;      &#125;      break;    &#125;  &#125;  return tab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>initTable方法执行逻辑为:</p><ol><li>判断哈希桶数组是否未生成，如果未生成则进入循环</li><li>进入循环后判断sizeCtl是否小于0，则说明其他线程正在对数组进行初始化或者扩容，让出线程执行的时间片，进行自旋</li><li>如果大于等于0，通过cas将sizeCtl改为-1。这里也分两种情况，一是哈希桶数组已经初始化(sc&gt;0)，二是哈希桶数组未进行初始化(sc=0)，因此需要继续判断是否哈希桶数组未进行初始化</li><li>如果数组未进行初始化，则进行初始化，并将sizeCtl的值设为初始数组长度的0.75倍；如果数组已经进行了初始化，则将sizeCtl设为原值</li></ol><p>如果当前哈希桶数组正在扩容，会调用helpTransfer方法，将当前线程也加入到扩容线程中，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;  Node&lt;K,V&gt;[] nextTab; int sc;  &#x2F;&#x2F;如果确定要扩容，并且nextTable不为空，则将当前线程加入扩容线程中  if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;    (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;    &#x2F;&#x2F;resizeStamp方法返回的是基于哈希桶数组生成的与数组大小有关的数字，其高16位为0，且第17位为1    int rs &#x3D; resizeStamp(tab.length);    while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;           (sc &#x3D; sizeCtl) &lt; 0) &#123;      &#x2F;&#x2F;if中第一个条件代表当前线程操作的数组和目前ConcurrentHashMap扩容的数组不是同一个数组（大小一致），第二和第三个条件在1.8中实际上是bug，实际上是用来判断数组是否已经扩容完成或是否达到最大扩容线程，第四个判断条件代表数组已扩容完成，如果有任一条件为真，则跳出循环      if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||        sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)        break;      if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;        &#x2F;&#x2F;调用transfer方法进行扩容        transfer(tab, nextTab);        break;      &#125;    &#125;    return nextTab;  &#125;  return table;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>helpTransfer方法的执行逻辑为：</p><ol><li>判断node中记录的nextTable是否为空，如果为空则不做任何操作</li><li>判断当前数组是否正在扩容，如果是，则判断node中记录的nextTab和当前ConcurrentHashMap中正在扩容的nextTable是否不是同一个数组（通过数组长度判断），数组是否已经扩容完成或已经达到最大扩容线程，如果任一条件为空，则直接跳出循环<br>（关于JDK1.8中的bug，详情见<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%89">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427）</a></li><li>如果当前线程可以加入扩容，则将sizeCtl加一，并调用transfer方法进行扩容</li></ol><p>其中transfer方法的实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;如果nextTab为空，则说明要进行扩容，如果不为空，则说明是其他线程来帮助数组扩容private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;  int n &#x3D; tab.length, stride;  &#x2F;&#x2F;stride代表每个线程扩容时，要负责将几个数组元素进行迁移(每个数组元素都是链表或者红黑树)  if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt;  MIN_TRANSFER_STRIDE)      stride &#x3D; MIN_TRANSFER_STRIDE;  &#x2F;&#x2F;如果没有给定扩容之后的nextTab，则需要进行初始化，nextTab长度为老的数组的长度的两倍  if (nextTab &#x3D;&#x3D; null) &#123;      try &#123;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];          nextTab &#x3D; nt;      &#125; catch (Throwable ex) &#123;          sizeCtl &#x3D; Integer.MAX_VALUE;          return;      &#125;      nextTable &#x3D; nextTab;      &#x2F;&#x2F;刚开始时，没有任何线程进行扩容，此时transferIndex代表数组最后，注意，transferIndex被volatite关键字修饰，对所有的线程来说，transferIndex的改变都是可见的      transferIndex &#x3D; n;  &#125;  int nextn &#x3D; nextTab.length;  ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);  boolean advance &#x3D; true;  boolean finishing &#x3D; false;  for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;      Node&lt;K,V&gt; f; int fh;      &#x2F;&#x2F;循环中开始分配当前线程要负责哪些元素的迁移，其中i代表当前线程正在操作的元素的下标（除了第一次循环），bound代表当前线程负责迁移的最小的元素的下标，每个线程总是先迁移下标最大的元素，这里的advance为true代表当前线程可以进行下一个元素的迁移（第一次进入的时候明显为true，之后得确保当前线程已经完成来当前元素的迁移，这样才能进行下一个元素的迁移）      while (advance) &#123;          int nextIndex, nextBound;          if (--i &gt;&#x3D; bound || finishing)              &#x2F;&#x2F;如果当前线程已经完成全部迁移任务，或者所有元素已经完成迁移，跳出循环              advance &#x3D; false;          else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;              &#x2F;&#x2F;如果数组中所有的元素都已经有线程负责迁移，则跳出循环              i &#x3D; -1;              advance &#x3D; false;          &#125;          else if (U.compareAndSwapInt                   (this, TRANSFERINDEX, nextIndex,                    nextBound &#x3D; (nextIndex &gt; stride ?                                 nextIndex - stride : 0))) &#123;              &#x2F;&#x2F;当前线程认领迁移任务，bound代表任务中最小下标，i代表当前操作的元素下标，刚认领任务时，i代表任务中最大下标              bound &#x3D; nextBound;              i &#x3D; nextIndex - 1;              advance &#x3D; false;          &#125;      &#125;      if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;          &#x2F;&#x2F;当前线程已经完成了任务，并且所有数组元素都有线程来负责迁移          int sc;          if (finishing) &#123;              &#x2F;&#x2F;如果所有的线程都已经完成了迁移任务，则将table指向新的哈希桶数组，同时将sizeCtl改为0.75n              nextTable &#x3D; null;              table &#x3D; nextTab;              sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);              return;          &#125;          &#x2F;&#x2F;当前线程已经完成了任务，将其从sizeCtl中减去          if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;              &#x2F;&#x2F;这个判断条件可以判断是否是最后一个线程，false代表当前线程不是最后一个扩容线程。调用transfer方法进行扩容时（入参的nextTab为空），因为调用线程也是一个线程，所以会将（resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT）+ 2赋值给sizeCtl，其中resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT低16位为0，符号位为1，即保证sizeCtl为负数，并且低16位为当前扩容线程+1              if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                  return;              &#x2F;&#x2F;如果是最后一个扩容线程，则将finishing改为true              finishing &#x3D; advance &#x3D; true;              i &#x3D; n;          &#125;      &#125;      else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)          &#x2F;&#x2F;如果该元素为空，则只需要将该元素改为ForwardingNode类型的node          advance &#x3D; casTabAt(tab, i, null, fwd);      else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)          advance &#x3D; true;      else &#123;          synchronized (f) &#123;              &#x2F;&#x2F;再次判断数组中同一位置的节点未变，防止扩容与插入同时进行              if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;                &#x2F;&#x2F;实际的迁移逻辑，重新计算链表&#x2F;红黑树中每个元素的hash值，放到新数组中                  Node&lt;K,V&gt; ln, hn;                  if (fh &gt;&#x3D; 0) &#123;                      int runBit &#x3D; fh &amp; n;                      Node&lt;K,V&gt; lastRun &#x3D; f;                      for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;                          int b &#x3D; p.hash &amp; n;                          if (b !&#x3D; runBit) &#123;                              runBit &#x3D; b;                              lastRun &#x3D; p;                          &#125;                      &#125;                      if (runBit &#x3D;&#x3D; 0) &#123;                          ln &#x3D; lastRun;                          hn &#x3D; null;                      &#125;                      else &#123;                          hn &#x3D; lastRun;                          ln &#x3D; null;                      &#125;                      for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;                          int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;                          if ((ph &amp; n) &#x3D;&#x3D; 0)                              ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);                          else                              hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);                      &#125;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;                  else if (f instanceof TreeBin) &#123;                      TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;                      TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;                      TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;                      int lc &#x3D; 0, hc &#x3D; 0;                      for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;                          int h &#x3D; e.hash;                          TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;                              (h, e.key, e.val, null, null);                          if ((h &amp; n) &#x3D;&#x3D; 0) &#123;                              if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)                                  lo &#x3D; p;                              else                                  loTail.next &#x3D; p;                              loTail &#x3D; p;                              ++lc;                          &#125;                          else &#123;                              if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)                                  hi &#x3D; p;                              else                                  hiTail.next &#x3D; p;                              hiTail &#x3D; p;                              ++hc;                          &#125;                      &#125;                      ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :                          (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                      hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :                          (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;              &#125;          &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入元素后，如果需要将链表转化为红黑树，则会调用treeifyBin方法，treeifyBin方法中同HashMap方法中一样，判断了数组长度是否小于64，如果小于64，则优先扩容</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)  &#x2F;&#x2F;tryPresize内部调用了transfer方法  tryPresize(n &lt;&lt; 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在putVal方法的最后，调用了addCount方法将ConcurrentHashMap的size+1，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final void addCount(long x, int check) &#123;    &#x2F;&#x2F;s代表执行此次addCount后ConcurrentHashMap的长度    CounterCell[] as; long b, s;    if ((as &#x3D; counterCells) !&#x3D; null ||        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;        CounterCell a; long v; int m;        boolean uncontended &#x3D; true;        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||            !(uncontended &#x3D;              U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;            fullAddCount(x, uncontended);            return;        &#125;        if (check &lt;&#x3D; 1)            return;        s &#x3D; sumCount();    &#125;    if (check &gt;&#x3D; 0) &#123;        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;               (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;            int rs &#x3D; resizeStamp(n);            &#x2F;&#x2F;sc小于0则代表在扩容，需要判断是否需要帮助扩容            if (sc &lt; 0) &#123;                &#x2F;&#x2F;if中第一个条件代表当前线程操作的数组和目前ConcurrentHashMap扩容的数组不是同一个数组（大小一致），第二和第三个条件为bug（同上文transfer方法），实际上是用来判断数组是否已经扩容完成或是否达到最大扩容线程，第四个判断条件代表数组已扩容完成，如果有任一条件为真，则跳出循环                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||                    transferIndex &lt;&#x3D; 0)                    break;                &#x2F;&#x2F;如果需要扩容，则当前线程帮助扩容                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            &#x2F;&#x2F;到这一步可以确定sc大于0，此时sc代表ConcurrentHashMap的容量，而while中判断了s&gt;sc，则说明当前ConcurrentHashMap的容量已经达到了上限，需要进行扩容            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s &#x3D; sumCount();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法的执行逻辑为用baseCount来保存ConcurrentHashMap的size，但是如果baseCount的cas操作竞争很激烈，则用CounterCell来保存每次每次putVal时要加的size值，每个线程都会通过getProbe方法获取在CounterCell数组中对应的位置，并将本线程要加的size值放入该位置，如果该位置有值，则会继续寻找数组中为空的元素进行操作</p><p>获取ConcurrentHashMap的size调用的是sumCount方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int size() &#123;    long n &#x3D; sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部调用了sumCount方法，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final long sumCount() &#123;    CounterCell[] as &#x3D; counterCells; CounterCell a;    long sum &#x3D; baseCount;    if (as !&#x3D; null) &#123;        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;            if ((a &#x3D; as[i]) !&#x3D; null)                sum +&#x3D; a.value;        &#125;    &#125;    return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上就是将baseCount和CounterCell中的值相加，就是ConcurrentHashMap的size</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析(JDK1.8)</title>
      <link href="2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在JDK1.8中，HashMap的数据结构为哈希桶数组，哈希桶数组为数组+链表，每个链表的头节点为数组重的一个元素，当链表中元素个数达到8个，并且数组长度大于64时，会将链表转化为红黑树。</p><h3 id="主要成员变量及含义"><a href="#主要成员变量及含义" class="headerlink" title="主要成员变量及含义"></a>主要成员变量及含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;默认数组大小，如果不指定则为16static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16&#x2F;&#x2F;数组最大长度，数值为2^30，当数组长度达到这个值时，数组不会再进行扩容static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;默认负载因子static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表转为红黑树时，链表最少应包含的元素个数static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;哈希桶数组扩容后，如果红黑树中元素个数少于6个，将会退化成链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;链表转化为红黑树时，数组的最小长度（如果数组长度小于64，则会进行扩容而不是将链表转化为红黑树）static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组。transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;当HashMap中包含多少个元素时，将进行扩容int threshold;&#x2F;&#x2F;实际的负载因子final float loadFactor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashMap的哈希桶数组使用transient关键字修饰。其原因主要是对于不同的虚拟机，同一个对象的hashCode的值并不一定一样，也就是对于同一个HashMap，在不同的虚拟机中，同一个元素所在的哈希桶数组的位置可能不一样；因此序列化的时候不保存哈希桶数组而只是保存HashMap中所有的元素，在反序列化的时候将所有元素取出，然后重新构建哈希桶数组。</p><p>不直接使用红黑树存储数据是因为树节点占用的空间大概为链表节点的两倍，而且红黑树插入元素时操作更加复杂。当链表长度为8的时候转化为红黑树是因为根据柏松分布，如果负载因子为0.75时，λ大概为0.5，这种情况下每个链表长度出现的概率为</p><table><thead><tr><th align="left">链表长度</th><th align="center">出现概率</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">0.60653066</td></tr><tr><td align="left">1</td><td align="center">0.30326533</td></tr><tr><td align="left">2</td><td align="center">0.07581633</td></tr><tr><td align="left">3</td><td align="center">0.01263606</td></tr><tr><td align="left">4</td><td align="center">0.00157952</td></tr><tr><td align="left">5</td><td align="center">0.00015795</td></tr><tr><td align="left">6</td><td align="center">0.00001316</td></tr><tr><td align="left">7</td><td align="center">0.00000094</td></tr><tr><td align="left">8</td><td align="center">0.00000006</td></tr></tbody></table><p>可以看到，链表长度为8出现的概率很小，因此这个时候转化为红黑树性价比很高</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap() &#123;  this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>无参构造函数只是将负载因子进行赋值，并没有构造哈希桶数组</p><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap(int initialCapacity, float loadFactor) &#123;  if (initialCapacity &lt; 0)      throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                          initialCapacity);  &#x2F;&#x2F;如果传入的初始数组大小大于最大长度，则取最大长度  if (initialCapacity &gt; MAXIMUM_CAPACITY)      initialCapacity &#x3D; MAXIMUM_CAPACITY;  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))      throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                          loadFactor);  this.loadFactor &#x3D; loadFactor;  this.threshold &#x3D; tableSizeFor(initialCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中对负载因子进行赋值，并根据入参中的初始长度生成threshold（此时的threshold等于数组长度，但在真正构建数组的时候会变为数组长度*负载因子）<br>  tableSizeFor方法代码如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int tableSizeFor(int cap) &#123;  int n &#x3D; cap - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，tableSizeFor中在return前的代码保证了n必定为2的幂次方-1，所以这个方法返回的数组长度必定为2的幂次方</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>HashMap添加元素的方法如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(hash(key), key, value, false, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>hash方法中根据key的hashCode进行了一次hash算法，这种hash算法，将hashCode的高16位和低16位都进行了运算，可以有效减少哈希碰撞，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int hash(Object key) &#123;  int h;  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>真正放入元素的方法为putVal，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;初始化哈希桶数组      n &#x3D; (tab &#x3D; resize()).length;  if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)      &#x2F;&#x2F;如果所在位置的数组元素为空，则直接放入数组该位置      tab[i] &#x3D; newNode(hash, key, value, null);  else &#123;    Node&lt;K,V&gt; e; K k;    &#x2F;&#x2F;这里的e用来保存根据key找到的node，如果不存在，则e为null    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      e &#x3D; p;    else if (p instanceof TreeNode)      &#x2F;&#x2F;如果数组的第一个元素是树形节点，则使用树形节点的putTreeVal方法      e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    else &#123;      &#x2F;&#x2F;到这一步就说明数组中该位置为链表      for (int binCount &#x3D; 0; ; ++binCount) &#123;          &#x2F;&#x2F;遍历链表，如果直到尾部都没有该元素，则在链表尾部新增元素，并判断是否要转变为红黑树        if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;            p.next &#x3D; newNode(hash, key, value, null);            if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)                treeifyBin(tab, hash);            break;        &#125;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            break;        p &#x3D; e;      &#125;    &#125;    &#x2F;&#x2F;如果e不为null，则说明在HashMap中存在put的元素，则将改变该key的value，并返回之前的value    if (e !&#x3D; null) &#123;      V oldValue &#x3D; e.value;      if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)          e.value &#x3D; value;      &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap向双向链表中插入元素      afterNodeAccess(e);      return oldValue;    &#125;  &#125;  ++modCount;  &#x2F;&#x2F;如果HashMap中的元素个数超过最大限度，则哈希桶数组进行扩容  if (++size &gt; threshold)    resize();  &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap根据规则删除node节点（例如LRU删除最早插入的节点）  afterNodeInsertion(evict);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal的主要逻辑如下：</p><ol><li>对哈希桶数组进行判断，如果哈希桶数组还未初始化，则调用resize方法进行初始化;</li><li>将hash值对数组长度进行取模，获取插入元素在数组中的位置，如果数组该位置为空，则直接构造元素，并放入数组对应位置；</li><li>如果数组该位置有值，则在链表（或红黑树）中寻找是否key已经存在，如果存在则修改value，并返回之前的value，如果不存在，则插入链表（或红黑树）中，并判断是否要将链表转化为红黑树；</li><li>判断元素插入后是否需要扩容，如果需要，则调用resize方法进行扩容</li></ol><p>  向链表中插入元素的时候，使用的是尾插法，而不是像JDK1.7中一样使用头插法。主要是因为在JDK1.7中，多线程环境下，如果哈希桶的扩容和元素插入同时进行，有可能会形成环形链表，导致get和put元素时会一直在环形链表中死循环。</p><p>putVal中初始化和扩容时都调用了resize方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) &#123;      &#x2F;&#x2F;如果老数组的长度大于0，则扩容      if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;        &#x2F;&#x2F;如果数组已经达到最大长度，则不进行扩容，直接返回当前数组        threshold &#x3D; Integer.MAX_VALUE;        return oldTab;      &#125;      else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;             oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)        &#x2F;&#x2F;否则将数组长度和threshold翻倍        newThr &#x3D; oldThr &lt;&lt; 1;    &#125;    else if (oldThr &gt; 0)      &#x2F;&#x2F;这里已经确定是数组还未初始化，如果threshold大于0，则说明HashMap是根据有参构造生成的，那么此时的threshold即为数组初始化长度      newCap &#x3D; oldThr;    else &#123;      &#x2F;&#x2F;这里确定数组未初始化，并且是HashMap根据无参构造生成的，因此直接使用默认值即可      newCap &#x3D; DEFAULT_INITIAL_CAPACITY;      newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F;如果HashMap是根据有参构造生成的，newThr并未被赋值，要重新计算threshold的值      float ft &#x3D; (float)newCap * loadFactor;      newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;    if (oldTab !&#x3D; null) &#123;      &#x2F;&#x2F;对扩容后的数组进行填充      for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;        Node&lt;K,V&gt; e;        &#x2F;&#x2F;对数组中每个元素的处理，要注意的是，如果老数组长度为n，元素所处的数组位置为i，则扩容后，这个元素所处的数组位置要么是i，要么是i+n        if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;          oldTab[j] &#x3D; null;          if (e.next &#x3D;&#x3D; null)            newTab[e.hash &amp; (newCap - 1)] &#x3D; e;          else if (e instanceof TreeNode)            &#x2F;&#x2F;对于树节点的处理，方法中判断了重新生成的两棵树是否元素个数大于6，如果不是的话，则红黑树会退化成链表            ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);          else &#123;            &#x2F;&#x2F;对于链表的处理            Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;            Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;            Node&lt;K,V&gt; next;            do &#123;              next &#x3D; e.next;              &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。（只有oldCap为2^n时才能这么判断）              if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                if (loTail &#x3D;&#x3D; null)                  loHead &#x3D; e;                else                  loTail.next &#x3D; e;                loTail &#x3D; e;              &#125;              else &#123;                if (hiTail &#x3D;&#x3D; null)                  hiHead &#x3D; e;                else                  hiTail.next &#x3D; e;                hiTail &#x3D; e;              &#125;            &#125; while ((e &#x3D; next) !&#x3D; null);            if (loTail !&#x3D; null) &#123;              loTail.next &#x3D; null;              newTab[j] &#x3D; loHead;            &#125;            if (hiTail !&#x3D; null) &#123;              hiTail.next &#x3D; null;              newTab[j + oldCap] &#x3D; hiHead;            &#125;          &#125;        &#125;      &#125;    &#125;    return newTab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>resize执行流程：</p><ol><li>判断数组长度是否大于0，如果大于0，说明数组已经初始化，再判断数组长度是否已达上限，达到上限则不进行扩容并直接返回，否则将数组长度和threshold翻倍</li><li>如果数组长度为0，要判断HashMap是根据有参构造方法还是无参构造方法生成的，主要根据threshold是否大于0来判断，有参构造方法生成时，哈希桶数组长度取threshold，如果是无参构造方法生成的HashMap，则将数组长度和threshold都取默认值</li><li>有参构造方法生成的HashMap要重新根据数组长度计算threshold的值</li><li>构造新的哈希桶数组，如果旧的哈希桶数组为null，说明本次是进行数组初始化，直接返回新的哈希桶数组</li><li>如果旧的哈希桶数组不为null，说明本次是进行数组扩容，则遍历数组，将链表（或红黑树）的每个节点重新计算新数组的位置，放入新数组中，如果一个节点处于旧数组的i位置（旧数组长度为n），则它在新数组中要么位于i位置（hash&amp;n==0）要么位于i+n位置（hash&amp;n==1）</li></ol><p>resize方法中扩容时，对树形节点调用了树节点的split方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;  TreeNode&lt;K,V&gt; b &#x3D; this;  TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;  TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;  int lc &#x3D; 0, hc &#x3D; 0;  &#x2F;&#x2F;将一颗红黑树变为两张链表  for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;    next &#x3D; (TreeNode&lt;K,V&gt;)e.next;    e.next &#x3D; null;    &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。    if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;      if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)        loHead &#x3D; e;      else        loTail.next &#x3D; e;      loTail &#x3D; e;      ++lc;    &#125;    else &#123;      if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)        hiHead &#x3D; e;      else        hiTail.next &#x3D; e;      hiTail &#x3D; e;      ++hc;    &#125;  &#125;  if (loHead !&#x3D; null) &#123;    &#x2F;&#x2F;判断是否需要将红黑树转换为链表    if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index] &#x3D; loHead.untreeify(map);    else &#123;      tab[index] &#x3D; loHead;      if (hiHead !&#x3D; null)        loHead.treeify(tab);    &#125;  &#125;  if (hiHead !&#x3D; null) &#123;    &#x2F;&#x2F;同上    if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index + bit] &#x3D; hiHead.untreeify(map);    else &#123;      tab[index + bit] &#x3D; hiHead;      if (loHead !&#x3D; null)        hiHead.treeify(tab);      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>split的逻辑为</p><ol><li>根据头节点取红黑树中的每个每个节点，并根据每个节点的hash值判断处于新数组的哪个位置，处于相同位置的节点构造为一个链表</li><li>每个红黑树迁移后最多变为两张链表，再根据链表中节点个数是否小于等于6来判断两张链表最终会变成链表还是红黑树</li></ol><p>在putVal方法中，构造红黑树调用了treeifyBin方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;  int n, index; Node&lt;K,V&gt; e;  &#x2F;&#x2F;如果哈希桶数组为空，或者数组长度小于64，先扩容，而不是转化为红黑树  if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)    resize();  else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;    do &#123;      TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);      if (tl &#x3D;&#x3D; null)        hd &#x3D; p;      else &#123;        p.prev &#x3D; tl;        tl.next &#x3D; p;      &#125;      tl &#x3D; p;    &#125; while ((e &#x3D; e.next) !&#x3D; null);    if ((tab[index] &#x3D; hd) !&#x3D; null)      hd.treeify(tab);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>treeifyBin方法中首先判断数组是否为空，如果不为空再判断数组长度是否小于64，如果小于64，则调用resize方法进行扩容（resize方法处理链表时并没有将链表转化为红黑树，因此在极端情况下，扩容后链表的元素如果还在数组同一个位置，则会出现元素个数超过8的链表）；如果大于等于64，再将链表转为红黑树</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>获取元素使用的是get方法，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V get(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际是根据getNode方法来获取元素的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;  &#x2F;&#x2F;先根据hash算出所在数组下标，然后遍历链表（红黑树）寻找hashCode等于key并且equals方法也为true的元素，如果有的话则返回，没有的话则返回null  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;    if (first.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      return first;    if ((e &#x3D; first.next) !&#x3D; null) &#123;      if (first instanceof TreeNode)          return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);      do &#123;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;          ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))          return e;      &#125; while ((e &#x3D; e.next) !&#x3D; null);    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>get方法先根据hash值判断要寻找数组中哪个位置，然后遍历链表（或红黑树），找到key相等并且equals为true的节点，返回其value值；如果找不到，则返回null</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>  移除元素使用的是remove方法，实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V remove(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?      null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  实际调用的是removeNode方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                         boolean matchValue, boolean movable) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;  &#x2F;&#x2F;先查找元素  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      node &#x3D; p;    else if ((e &#x3D; p.next) !&#x3D; null) &#123;      if (p instanceof TreeNode)        node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);      else &#123;        do &#123;          if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key ||             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;            node &#x3D; e;            break;          &#125;          p &#x3D; e;        &#125; while ((e &#x3D; e.next) !&#x3D; null);      &#125;    &#125;    &#x2F;&#x2F;如果存在的话则删除    if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||(value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;      if (node instanceof TreeNode)        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);      else if (node &#x3D;&#x3D; p)        tab[index] &#x3D; node.next;      else        p.next &#x3D; node.next;      ++modCount;      --size;      &#x2F;&#x2F;这里是个空实现，主要是为了删除元素后LinkedHashMap对双向链表进行删除      afterNodeRemoval(node);      return node;    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>removeNode方法与get方法获取元素的方式一致，如果找到了对应的key则删除。这里值得注意的一点是树节点的删除，调用了removeTreeNode方法，里面对于红黑树退化成链表的判断逻辑如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是remove可能会导致出现只要4个节点的红黑树</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>  序列化使用的是writeObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void writeObject(java.io.ObjectOutputStream s)    throws IOException &#123;  int buckets &#x3D; capacity();  &#x2F;&#x2F;写入threshold、loadfactor等属性  s.defaultWriteObject();  &#x2F;&#x2F;写入数组大小  s.writeInt(buckets);  &#x2F;&#x2F;写入元素个数  s.writeInt(size);  &#x2F;&#x2F;写入哈希桶数组中每个元素  internalWriteEntries(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化的时候除了常用的属性写入字节流外，还将每个节点写入了字节流</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>  反序列化使用的是readObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;  &#x2F;&#x2F;获取threshold，loadfactor等属性  s.defaultReadObject();  &#x2F;&#x2F;初始化必要的属性  reinitialize();  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))    throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                     loadFactor);  &#x2F;&#x2F;读取写入时的buckets  s.readInt();        &#x2F;&#x2F;读取HashMap中元素的个数            int mappings &#x3D; s.readInt();  if (mappings &lt; 0)    throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +mappings);  else if (mappings &gt; 0) &#123;    &#x2F;&#x2F;根据元素个数确定哈希桶数组大小    float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);    float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;    int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?               DEFAULT_INITIAL_CAPACITY :               (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?               MAXIMUM_CAPACITY :               tableSizeFor((int)fc));    float ft &#x3D; (float)cap * lf;    threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                 (int)ft : Integer.MAX_VALUE);    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];    table &#x3D; tab;    &#x2F;&#x2F;读取每个元素，并调用putVal方法重新构建哈希桶数组    for (int i &#x3D; 0; i &lt; mappings; i++) &#123;      @SuppressWarnings(&quot;unchecked&quot;)      K key &#x3D; (K) s.readObject();      @SuppressWarnings(&quot;unchecked&quot;)      V value &#x3D; (V) s.readObject();      putVal(hash(key), key, value, false, false);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反序列化则是将字节流中的每个元素取出来，再放入到哈希桶数组中</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
