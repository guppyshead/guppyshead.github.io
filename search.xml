<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ConcurrentHashMap源码解析</title>
      <link href="2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/19/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>JDK1.8版本的ConcurrentHashMap与JDK1.7采用了不同的实现。不同于JDK1.7中segment+哈希桶数组，JDK1.8使用的数据结构为一个哈希桶数组，同时由于1.8中CAS的支持，在1.8中使用CAS+synchronize锁来实现线程安全。</p><h3 id="主要成员变量及其含义"><a href="#主要成员变量及其含义" class="headerlink" title="主要成员变量及其含义"></a>主要成员变量及其含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;数组最大长度private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;数组默认长度private static final int DEFAULT_CAPACITY &#x3D; 16;&#x2F;&#x2F;默认并发数，在JDK1.7中用来指定segment的默认个数，在1.8中基本已不再使用private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;&#x2F;&#x2F;负载因子private static final float LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表节点数超过8个时转换为红黑树static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;红黑树节点数少于6个时退化为链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;哈希桶数组长度小于64时，链表节点数超过8个，哈希桶数组会优先扩容而不是将链表转化为红黑树static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组扩容时，每个线程负责迁移的节点个数的最小步长private static final int MIN_TRANSFER_STRIDE &#x3D; 16;&#x2F;&#x2F;sizeCtl中用来存储扩容线程个数信息的二进制位数（低16位）private static int RESIZE_STAMP_BITS &#x3D; 16;&#x2F;&#x2F;数组扩容时，最多允许的线程数private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;&#x2F;&#x2F;sizeCtl中用来存储数组大小信息的二进制位数（高16位）private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;&#x2F;&#x2F;哈希桶数组transient volatile Node&lt;K,V&gt;[] table;&#x2F;&#x2F;扩容过程中新的哈希桶数组private transient volatile Node&lt;K,V&gt;[] nextTable;&#x2F;&#x2F;基础数组长度（实际数组长度可能比这个值大）private transient volatile long baseCount;&#x2F;&#x2F;值为-1时代表正在初始化，其他负数代表数组正在进行扩容，扩容时高16位与哈希桶数组大小有关，低16位为扩容的线程数+1private transient volatile int sizeCtl;&#x2F;&#x2F;数组扩容时还未被分配扩容线程的最大indexprivate transient volatile int transferIndex;&#x2F;&#x2F;扩容时，CounterCell数组的锁private transient volatile int cellsBusy;&#x2F;&#x2F;扩容时，如果baseCount并发量太高，则将要增加的数组长度放到这个数组中（一般来说，数组长度为baseCount和这个数组中所有元素之和）private transient volatile CounterCell[] counterCells;&#x2F;&#x2F;节点正在被移动时，头节点的hash值static final int MOVED     &#x3D; -1;&#x2F;&#x2F;树形节点根节点的hash值static final int TREEBIN   &#x3D; -2;&#x2F;&#x2F;使用computeIfAbsent方法时，节点的hash值static final int RESERVED  &#x3D; -3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存节点的哈希桶数组使用transient关键字修饰，其目的与HashMap一致，都是因为在同一个对象在不同虚拟机中的hashCode可能不一致，因此对ConcurrentHashMap序列化时只序列化每个节点，反序列化时取出每个节点重新构建哈希桶数组。</p><p>###构造函数<br>####无参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无参构造函数只是一个空实现，没有进行任何处理<br>####有参构造</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ConcurrentHashMap(int initialCapacity,                       float loadFactor, int concurrencyLevel) &#123;  if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)    throw new IllegalArgumentException();  if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins    initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads  long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);  int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : tableSizeFor((int)size);  this.sizeCtl &#x3D; cap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中，根据给定的入参计算出数组初始长度（2^n），并将其赋值给sizeCtl，其中，tableSizeFor函数的实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static final int tableSizeFor(int c) &#123;  int n &#x3D; c - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过位运算，保证数组长度必定位2^n</p><p>###添加元素<br>添加元素使用的是put方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(key, value, false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>内部直接调用了putVal方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;  if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();  &#x2F;&#x2F;计算hash值  int hash &#x3D; spread(key.hashCode());  int binCount &#x3D; 0;  for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;    Node&lt;K,V&gt; f; int n, i, fh;    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;如果哈希桶数组未初始化，则先初始化哈希桶数组      tab &#x3D; initTable();    else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;      &#x2F;&#x2F;如果要添加的元素所在的数组位置为空，则直接使用cas操作将元素添加进去，成功则跳出循环      if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))        break;    &#125;    else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)      &#x2F;&#x2F;如果添加的元素所在数组位置头节点被移动了，说明正在进行数组扩容，则当前线程也帮忙进行扩容      tab &#x3D; helpTransfer(tab, f);    else &#123;      V oldVal &#x3D; null;      &#x2F;&#x2F;根据数组位置寻找头节点，然后进行插入，这里对头节点进行加锁并比较，是为了防止代码运行到这里时，扩容和插入同时进行      synchronized (f) &#123;        if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;          if (fh &gt;&#x3D; 0) &#123;            binCount &#x3D; 1;            &#x2F;&#x2F;遍历链表，如果找到key相等且equals方法为true的节点，则修改并返回旧值，否则插入并返回null            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;              K ek;              if (e.hash &#x3D;&#x3D; hash &amp;&amp;                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;                oldVal &#x3D; e.val;                if (!onlyIfAbsent)                    e.val &#x3D; value;                break;              &#125;              Node&lt;K,V&gt; pred &#x3D; e;              if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,value, null);                break;              &#125;            &#125;          &#125;          else if (f instanceof TreeBin) &#123;            &#x2F;&#x2F;如果是树节点，则使用树节点的putVal方法            Node&lt;K,V&gt; p;            binCount &#x3D; 2;            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) !&#x3D; null) &#123;              oldVal &#x3D; p.val;              if (!onlyIfAbsent)                  p.val &#x3D; value;            &#125;          &#125;        &#125;      &#125;      if (binCount !&#x3D; 0) &#123;        &#x2F;&#x2F;插入成功后，判断是否需要将链表变为数组        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)          treeifyBin(tab, i);        if (oldVal !&#x3D; null)          return oldVal;        break;      &#125;    &#125;  &#125;  &#x2F;&#x2F;将ConcurrentHashMap的size加一  addCount(1L, binCount);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal方法的执行逻辑为：</p><ol><li>调用spread方法计算插入节点的hash值</li><li>判断哈希桶数组是否为空，如果为空，则先调用initTable方法初始化数组，进入下一次循环</li><li>如果不为空，则找到插入节点所在的数组位置，如果该位置为空，则使用cas操作将要插入的节点放在数组该位置并跳出循环</li><li>如果该位置不为空，则对该位置进行加锁。加锁失败进入下一个循环，加锁成功则先比较数组该位置头节点在加锁前后是否改变，如果改变了，则说明当前在进行扩容，进入下一次循环</li><li>如果没有改变，说明只有当前线程在操作链表（红黑树），先查看头节点哈希值是否大于等于0（树形节点哈希值小于0），如果大于等于0，则数组该位置说明为链表，遍历链表，如果key已经存在，则替换value值，否则在链表结尾添加新节点</li><li>如果头节点的哈希值小于0，则判断是否为树形节点，如果是的话，调用树形节点的putTreeVal方法</li><li>添加元素结束后，调用addCount方法将ConcurrentHashMap的size加一</li></ol><p>如果哈希桶数组未初始化，则会先调用initTable方法进行数组的初始化，其实现如下：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final Node&lt;K,V&gt;[] initTable() &#123;  Node&lt;K,V&gt;[] tab; int sc;  &#x2F;&#x2F;如果一次循环结束哈希桶数组还未初始化，则再次进入循环  while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F;如果sizeCtl小于0，则说明数组正在进行初始化或者正在扩容，让出线程的时间片，进行自旋    if ((sc &#x3D; sizeCtl) &lt; 0)      Thread.yield();    else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;      &#x2F;&#x2F;如果通过cas操作将sc置为-1成功，则说明获得了初始化线程的锁，开始初始化线程      try &#123;        &#x2F;&#x2F;再次判断哈希桶数组是否未初始化，防止其他线程初始化并放入元素后（此时sc&gt;0），本线程获得锁，然后重新将哈希桶数组初始化        if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;          &#x2F;&#x2F;如果sc大于0，则说明ConcurrentHashMap是通过有参构造生成的，此时sc即为数组大小，否则，说明ConcurrentHashMap是通过无参构造生成的，直接使用默认数组大小          int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];          table &#x3D; tab &#x3D; nt;          &#x2F;&#x2F;sc等于0.75n，          sc &#x3D; n - (n &gt;&gt;&gt; 2);        &#125;      &#125; finally &#123;        &#x2F;&#x2F;假如数组初始化后通过cas操作将sizeCtl置为-1，但实际未通过try中的if判断，则需要将sizeCtl改为原来的值；如果进入了if判断，则将sizeCtl改为数组长度的0.75倍        sizeCtl &#x3D; sc;      &#125;      break;    &#125;  &#125;  return tab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>initTable方法执行逻辑为:</p><ol><li>判断哈希桶数组是否未生成，如果未生成则进入循环</li><li>进入循环后判断sizeCtl是否小于0，则说明其他线程正在对数组进行初始化或者扩容，让出线程执行的时间片，进行自旋</li><li>如果大于等于0，通过cas将sizeCtl改为-1。这里也分两种情况，一是哈希桶数组已经初始化(sc&gt;0)，二是哈希桶数组未进行初始化(sc=0)，因此需要继续判断是否哈希桶数组未进行初始化</li><li>如果数组未进行初始化，则进行初始化，并将sizeCtl的值设为初始数组长度的0.75倍；如果数组已经进行了初始化，则将sizeCtl设为原值</li></ol><p>如果当前哈希桶数组正在扩容，会调用helpTransfer方法，将当前线程也加入到扩容线程中，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;  Node&lt;K,V&gt;[] nextTab; int sc;  &#x2F;&#x2F;如果确定要扩容，并且nextTable不为空，则将当前线程加入扩容线程中  if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;    (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123;    &#x2F;&#x2F;resizeStamp方法返回的是基于哈希桶数组生成的与数组大小有关的数字，其高16位为0，且第17位为1    int rs &#x3D; resizeStamp(tab.length);    while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;           (sc &#x3D; sizeCtl) &lt; 0) &#123;      &#x2F;&#x2F;if中第一个条件代表当前线程操作的数组和目前ConcurrentHashMap扩容的数组不是同一个数组（大小一致），第二和第三个条件在1.8中实际上是bug，实际上是用来判断数组是否已经扩容完成或是否达到最大扩容线程，第四个判断条件代表数组已扩容完成，如果有任一条件为真，则跳出循环      if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||        sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0)        break;      if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;        &#x2F;&#x2F;调用transfer方法进行扩容        transfer(tab, nextTab);        break;      &#125;    &#125;    return nextTab;  &#125;  return table;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>helpTransfer方法的执行逻辑为：</p><ol><li>判断node中记录的nextTable是否为空，如果为空则不做任何操作</li><li>判断当前数组是否正在扩容，如果是，则判断node中记录的nextTab和当前ConcurrentHashMap中正在扩容的nextTable是否不是同一个数组（通过数组长度判断），数组是否已经扩容完成或已经达到最大扩容线程，如果任一条件为空，则直接跳出循环<br>（关于JDK1.8中的bug，详情见<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427%EF%BC%89">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427）</a></li><li>如果当前线程可以加入扩容，则将sizeCtl加一，并调用transfer方法进行扩容</li></ol><p>其中transfer方法的实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;如果nextTab为空，则说明要进行扩容，如果不为空，则说明是其他线程来帮助数组扩容private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;  int n &#x3D; tab.length, stride;  &#x2F;&#x2F;stride代表每个线程扩容时，要负责将几个数组元素进行迁移(每个数组元素都是链表或者红黑树)  if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt;  MIN_TRANSFER_STRIDE)      stride &#x3D; MIN_TRANSFER_STRIDE;  &#x2F;&#x2F;如果没有给定扩容之后的nextTab，则需要进行初始化，nextTab长度为老的数组的长度的两倍  if (nextTab &#x3D;&#x3D; null) &#123;      try &#123;          @SuppressWarnings(&quot;unchecked&quot;)          Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];          nextTab &#x3D; nt;      &#125; catch (Throwable ex) &#123;          sizeCtl &#x3D; Integer.MAX_VALUE;          return;      &#125;      nextTable &#x3D; nextTab;      &#x2F;&#x2F;刚开始时，没有任何线程进行扩容，此时transferIndex代表数组最后，注意，transferIndex被volatite关键字修饰，对所有的线程来说，transferIndex的改变都是可见的      transferIndex &#x3D; n;  &#125;  int nextn &#x3D; nextTab.length;  ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);  boolean advance &#x3D; true;  boolean finishing &#x3D; false;  for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;      Node&lt;K,V&gt; f; int fh;      &#x2F;&#x2F;循环中开始分配当前线程要负责哪些元素的迁移，其中i代表当前线程正在操作的元素的下标（除了第一次循环），bound代表当前线程负责迁移的最小的元素的下标，每个线程总是先迁移下标最大的元素，这里的advance为true代表当前线程可以进行下一个元素的迁移（第一次进入的时候明显为true，之后得确保当前线程已经完成来当前元素的迁移，这样才能进行下一个元素的迁移）      while (advance) &#123;          int nextIndex, nextBound;          if (--i &gt;&#x3D; bound || finishing)              &#x2F;&#x2F;如果当前线程已经完成全部迁移任务，或者所有元素已经完成迁移，跳出循环              advance &#x3D; false;          else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;              &#x2F;&#x2F;如果数组中所有的元素都已经有线程负责迁移，则跳出循环              i &#x3D; -1;              advance &#x3D; false;          &#125;          else if (U.compareAndSwapInt                   (this, TRANSFERINDEX, nextIndex,                    nextBound &#x3D; (nextIndex &gt; stride ?                                 nextIndex - stride : 0))) &#123;              &#x2F;&#x2F;当前线程认领迁移任务，bound代表任务中最小下标，i代表当前操作的元素下标，刚认领任务时，i代表任务中最大下标              bound &#x3D; nextBound;              i &#x3D; nextIndex - 1;              advance &#x3D; false;          &#125;      &#125;      if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;          &#x2F;&#x2F;当前线程已经完成了任务，并且所有数组元素都有线程来负责迁移          int sc;          if (finishing) &#123;              &#x2F;&#x2F;如果所有的线程都已经完成了迁移任务，则将table指向新的哈希桶数组，同时将sizeCtl改为0.75n              nextTable &#x3D; null;              table &#x3D; nextTab;              sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);              return;          &#125;          &#x2F;&#x2F;当前线程已经完成了任务，将其从sizeCtl中减去          if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;              &#x2F;&#x2F;这个判断条件可以判断是否是最后一个线程，false代表当前线程不是最后一个扩容线程。调用transfer方法进行扩容时（入参的nextTab为空），因为调用线程也是一个线程，所以会将（resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT）+ 2赋值给sizeCtl，其中resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT低16位为0，符号位为1，即保证sizeCtl为负数，并且低16位为当前扩容线程+1              if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                  return;              &#x2F;&#x2F;如果是最后一个扩容线程，则将finishing改为true              finishing &#x3D; advance &#x3D; true;              i &#x3D; n;          &#125;      &#125;      else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)          &#x2F;&#x2F;如果该元素为空，则只需要将该元素改为ForwardingNode类型的node          advance &#x3D; casTabAt(tab, i, null, fwd);      else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)          advance &#x3D; true;      else &#123;          synchronized (f) &#123;              &#x2F;&#x2F;再次判断数组中同一位置的节点未变，防止扩容与插入同时进行              if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;                &#x2F;&#x2F;实际的迁移逻辑，重新计算链表&#x2F;红黑树中每个元素的hash值，放到新数组中                  Node&lt;K,V&gt; ln, hn;                  if (fh &gt;&#x3D; 0) &#123;                      int runBit &#x3D; fh &amp; n;                      Node&lt;K,V&gt; lastRun &#x3D; f;                      for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;                          int b &#x3D; p.hash &amp; n;                          if (b !&#x3D; runBit) &#123;                              runBit &#x3D; b;                              lastRun &#x3D; p;                          &#125;                      &#125;                      if (runBit &#x3D;&#x3D; 0) &#123;                          ln &#x3D; lastRun;                          hn &#x3D; null;                      &#125;                      else &#123;                          hn &#x3D; lastRun;                          ln &#x3D; null;                      &#125;                      for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;                          int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;                          if ((ph &amp; n) &#x3D;&#x3D; 0)                              ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);                          else                              hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);                      &#125;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;                  else if (f instanceof TreeBin) &#123;                      TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;                      TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;                      TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;                      int lc &#x3D; 0, hc &#x3D; 0;                      for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;                          int h &#x3D; e.hash;                          TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;                              (h, e.key, e.val, null, null);                          if ((h &amp; n) &#x3D;&#x3D; 0) &#123;                              if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)                                  lo &#x3D; p;                              else                                  loTail.next &#x3D; p;                              loTail &#x3D; p;                              ++lc;                          &#125;                          else &#123;                              if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)                                  hi &#x3D; p;                              else                                  hiTail.next &#x3D; p;                              hiTail &#x3D; p;                              ++hc;                          &#125;                      &#125;                      ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :                          (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                      hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :                          (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                      setTabAt(nextTab, i, ln);                      setTabAt(nextTab, i + n, hn);                      setTabAt(tab, i, fwd);                      advance &#x3D; true;                  &#125;              &#125;          &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在putVal方法的最后，调用了addCount方法将ConcurrentHashMap的size+1，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private final void addCount(long x, int check) &#123;    CounterCell[] as; long b, s;    if ((as &#x3D; counterCells) !&#x3D; null ||        !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123;        CounterCell a; long v; int m;        boolean uncontended &#x3D; true;        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||            (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||            !(uncontended &#x3D;              U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123;            fullAddCount(x, uncontended);            return;        &#125;        if (check &lt;&#x3D; 1)            return;        s &#x3D; sumCount();    &#125;    if (check &gt;&#x3D; 0) &#123;        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;               (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;            int rs &#x3D; resizeStamp(n);            if (sc &lt; 0) &#123;                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||                    transferIndex &lt;&#x3D; 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s &#x3D; sumCount();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法的执行逻辑为用baseCount来保存ConcurrentHashMap的size，但是如果baseCount的cas操作竞争很激烈，则用CounterCell来保存每次每次putVal时要加的size值，每个线程都会通过getProbe方法获取在CounterCell数组中对应的位置，并将本线程要加的size值放入该位置，如果该位置有值，则会继续寻找数组中为空的元素进行操作</p><p>获取ConcurrentHashMap的size调用的是sumCount方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int size() &#123;    long n &#x3D; sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部调用了sumCount方法，其实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final long sumCount() &#123;    CounterCell[] as &#x3D; counterCells; CounterCell a;    long sum &#x3D; baseCount;    if (as !&#x3D; null) &#123;        for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;            if ((a &#x3D; as[i]) !&#x3D; null)                sum +&#x3D; a.value;        &#125;    &#125;    return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上就是将baseCount和CounterCell中的值相加，就是ConcurrentHashMap的size</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析(JDK1.8)</title>
      <link href="2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/05/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在JDK1.8中，HashMap的数据结构为哈希桶数组，哈希桶数组为数组+链表，每个链表的头节点为数组重的一个元素，当链表中元素个数达到8个，并且数组长度大于64时，会将链表转化为红黑树。</p><h3 id="主要成员变量及含义"><a href="#主要成员变量及含义" class="headerlink" title="主要成员变量及含义"></a>主要成员变量及含义</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;默认数组大小，如果不指定则为16static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16&#x2F;&#x2F;数组最大长度，数值为2^30，当数组长度达到这个值时，数组不会再进行扩容static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;默认负载因子static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;链表转为红黑树时，链表最少应包含的元素个数static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;哈希桶数组扩容后，如果红黑树中元素个数少于6个，将会退化成链表static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;链表转化为红黑树时，数组的最小长度（如果数组长度小于64，则会进行扩容而不是将链表转化为红黑树）static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;哈希桶数组。transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;当HashMap中包含多少个元素时，将进行扩容int threshold;&#x2F;&#x2F;实际的负载因子final float loadFactor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashMap的哈希桶数组使用transient关键字修饰。其原因主要是对于不同的虚拟机，同一个对象的hashCode的值并不一定一样，也就是对于同一个HashMap，在不同的虚拟机中，同一个元素所在的哈希桶数组的位置可能不一样；因此序列化的时候不保存哈希桶数组而只是保存HashMap中所有的元素，在反序列化的时候将所有元素取出，然后重新构建哈希桶数组。</p><p>不直接使用红黑树存储数据是因为树节点占用的空间大概为链表节点的两倍，而且红黑树插入元素时操作更加复杂。当链表长度为8的时候转化为红黑树是因为根据柏松分布，如果负载因子为0.75时，λ大概为0.5，这种情况下每个链表长度出现的概率为</p><table><thead><tr><th align="left">链表长度</th><th align="center">出现概率</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">0.60653066</td></tr><tr><td align="left">1</td><td align="center">0.30326533</td></tr><tr><td align="left">2</td><td align="center">0.07581633</td></tr><tr><td align="left">3</td><td align="center">0.01263606</td></tr><tr><td align="left">4</td><td align="center">0.00157952</td></tr><tr><td align="left">5</td><td align="center">0.00015795</td></tr><tr><td align="left">6</td><td align="center">0.00001316</td></tr><tr><td align="left">7</td><td align="center">0.00000094</td></tr><tr><td align="left">8</td><td align="center">0.00000006</td></tr></tbody></table><p>可以看到，链表长度为8出现的概率很小，因此这个时候转化为红黑树性价比很高</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap() &#123;  this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>无参构造函数只是将负载因子进行赋值，并没有构造哈希桶数组</p><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public HashMap(int initialCapacity, float loadFactor) &#123;  if (initialCapacity &lt; 0)      throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                          initialCapacity);  &#x2F;&#x2F;如果传入的初始数组大小大于最大长度，则取最大长度  if (initialCapacity &gt; MAXIMUM_CAPACITY)      initialCapacity &#x3D; MAXIMUM_CAPACITY;  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))      throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                          loadFactor);  this.loadFactor &#x3D; loadFactor;  this.threshold &#x3D; tableSizeFor(initialCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有参构造函数中对负载因子进行赋值，并根据入参中的初始长度生成threshold（此时的threshold等于数组长度，但在真正构建数组的时候会变为数组长度*负载因子）<br>  tableSizeFor方法代码如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int tableSizeFor(int cap) &#123;  int n &#x3D; cap - 1;  &#x2F;&#x2F;保证n用二进制表示时最高2位为1（这里的最高位指二进制表示时从左到右数，第一个不为0的位置，如果n用二进制表示时小于等于2位，则从最高位起每一位都已经被改为1，以下同理）  n |&#x3D; n &gt;&gt;&gt; 1;  &#x2F;&#x2F;保证n用二进制表示时最高4位为1  n |&#x3D; n &gt;&gt;&gt; 2;  &#x2F;&#x2F;保证n用二进制表示时最高8位为1  n |&#x3D; n &gt;&gt;&gt; 4;  &#x2F;&#x2F;保证n用二进制表示时最高16位为1  n |&#x3D; n &gt;&gt;&gt; 8;  &#x2F;&#x2F;保证n用二进制表示时最高32位为1  n |&#x3D; n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，tableSizeFor中在return前的代码保证了n必定为2的幂次方-1，所以这个方法返回的数组长度必定为2的幂次方</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>HashMap添加元素的方法如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V put(K key, V value) &#123;  return putVal(hash(key), key, value, false, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>hash方法中根据key的hashCode进行了一次hash算法，这种hash算法，将hashCode的高16位和低16位都进行了运算，可以有效减少哈希碰撞，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final int hash(Object key) &#123;  int h;  return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>真正放入元素的方法为putVal，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)      &#x2F;&#x2F;初始化哈希桶数组      n &#x3D; (tab &#x3D; resize()).length;  if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)      &#x2F;&#x2F;如果所在位置的数组元素为空，则直接放入数组该位置      tab[i] &#x3D; newNode(hash, key, value, null);  else &#123;    Node&lt;K,V&gt; e; K k;    &#x2F;&#x2F;这里的e用来保存根据key找到的node，如果不存在，则e为null    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      e &#x3D; p;    else if (p instanceof TreeNode)      &#x2F;&#x2F;如果数组的第一个元素是树形节点，则使用树形节点的putTreeVal方法      e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    else &#123;      &#x2F;&#x2F;到这一步就说明数组中该位置为链表      for (int binCount &#x3D; 0; ; ++binCount) &#123;          &#x2F;&#x2F;遍历链表，如果直到尾部都没有该元素，则在链表尾部新增元素，并判断是否要转变为红黑树        if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;            p.next &#x3D; newNode(hash, key, value, null);            if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)                treeifyBin(tab, hash);            break;        &#125;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            break;        p &#x3D; e;      &#125;    &#125;    &#x2F;&#x2F;如果e不为null，则说明在HashMap中存在put的元素，则将改变该key的value，并返回之前的value    if (e !&#x3D; null) &#123;      V oldValue &#x3D; e.value;      if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)          e.value &#x3D; value;      &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap向双向链表中插入元素      afterNodeAccess(e);      return oldValue;    &#125;  &#125;  ++modCount;  &#x2F;&#x2F;如果HashMap中的元素个数超过最大限度，则哈希桶数组进行扩容  if (++size &gt; threshold)    resize();  &#x2F;&#x2F;这是个空实现，主要为了LinkedHashMap根据规则删除node节点（例如LRU删除最早插入的节点）  afterNodeInsertion(evict);  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putVal的主要逻辑如下：</p><ol><li>对哈希桶数组进行判断，如果哈希桶数组还未初始化，则调用resize方法进行初始化;</li><li>将hash值对数组长度进行取模，获取插入元素在数组中的位置，如果数组该位置为空，则直接构造元素，并放入数组对应位置；</li><li>如果数组该位置有值，则在链表（或红黑树）中寻找是否key已经存在，如果存在则修改value，并返回之前的value，如果不存在，则插入链表（或红黑树）中，并判断是否要将链表转化为红黑树；</li><li>判断元素插入后是否需要扩容，如果需要，则调用resize方法进行扩容</li></ol><p>  向链表中插入元素的时候，使用的是尾插法，而不是像JDK1.7中一样使用头插法。主要是因为在JDK1.7中，多线程环境下，如果哈希桶的扩容和元素插入同时进行，有可能会形成环形链表，导致get和put元素时会一直在环形链表中死循环。</p><p>putVal中初始化和扩容时都调用了resize方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) &#123;      &#x2F;&#x2F;如果老数组的长度大于0，则扩容      if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;        &#x2F;&#x2F;如果数组已经达到最大长度，则不进行扩容，直接返回当前数组        threshold &#x3D; Integer.MAX_VALUE;        return oldTab;      &#125;      else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;             oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)        &#x2F;&#x2F;否则将数组长度和threshold翻倍        newThr &#x3D; oldThr &lt;&lt; 1;    &#125;    else if (oldThr &gt; 0)      &#x2F;&#x2F;这里已经确定是数组还未初始化，如果threshold大于0，则说明HashMap是根据有参构造生成的，那么此时的threshold即为数组初始化长度      newCap &#x3D; oldThr;    else &#123;      &#x2F;&#x2F;这里确定数组未初始化，并且是HashMap根据无参构造生成的，因此直接使用默认值即可      newCap &#x3D; DEFAULT_INITIAL_CAPACITY;      newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F;如果HashMap是根据有参构造生成的，newThr并未被赋值，要重新计算threshold的值      float ft &#x3D; (float)newCap * loadFactor;      newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;    if (oldTab !&#x3D; null) &#123;      &#x2F;&#x2F;对扩容后的数组进行填充      for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;        Node&lt;K,V&gt; e;        &#x2F;&#x2F;对数组中每个元素的处理，要注意的是，如果老数组长度为n，元素所处的数组位置为i，则扩容后，这个元素所处的数组位置要么是i，要么是i+n        if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;          oldTab[j] &#x3D; null;          if (e.next &#x3D;&#x3D; null)            newTab[e.hash &amp; (newCap - 1)] &#x3D; e;          else if (e instanceof TreeNode)            &#x2F;&#x2F;对于树节点的处理，方法中判断了重新生成的两棵树是否元素个数大于6，如果不是的话，则红黑树会退化成链表            ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);          else &#123;            &#x2F;&#x2F;对于链表的处理            Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;            Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;            Node&lt;K,V&gt; next;            do &#123;              next &#x3D; e.next;              &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。（只有oldCap为2^n时才能这么判断）              if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                if (loTail &#x3D;&#x3D; null)                  loHead &#x3D; e;                else                  loTail.next &#x3D; e;                loTail &#x3D; e;              &#125;              else &#123;                if (hiTail &#x3D;&#x3D; null)                  hiHead &#x3D; e;                else                  hiTail.next &#x3D; e;                hiTail &#x3D; e;              &#125;            &#125; while ((e &#x3D; next) !&#x3D; null);            if (loTail !&#x3D; null) &#123;              loTail.next &#x3D; null;              newTab[j] &#x3D; loHead;            &#125;            if (hiTail !&#x3D; null) &#123;              hiTail.next &#x3D; null;              newTab[j + oldCap] &#x3D; hiHead;            &#125;          &#125;        &#125;      &#125;    &#125;    return newTab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>resize执行流程：</p><ol><li>判断数组长度是否大于0，如果大于0，说明数组已经初始化，再判断数组长度是否已达上限，达到上限则不进行扩容并直接返回，否则将数组长度和threshold翻倍</li><li>如果数组长度为0，要判断HashMap是根据有参构造方法还是无参构造方法生成的，主要根据threshold是否大于0来判断，有参构造方法生成时，哈希桶数组长度取threshold，如果是无参构造方法生成的HashMap，则将数组长度和threshold都取默认值</li><li>有参构造方法生成的HashMap要重新根据数组长度计算threshold的值</li><li>构造新的哈希桶数组，如果旧的哈希桶数组为null，说明本次是进行数组初始化，直接返回新的哈希桶数组</li><li>如果旧的哈希桶数组不为null，说明本次是进行数组扩容，则遍历数组，将链表（或红黑树）的每个节点重新计算新数组的位置，放入新数组中，如果一个节点处于旧数组的i位置（旧数组长度为n），则它在新数组中要么位于i位置（hash&amp;n==0）要么位于i+n位置（hash&amp;n==1）</li></ol><p>resize方法中扩容时，对树形节点调用了树节点的split方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;  TreeNode&lt;K,V&gt; b &#x3D; this;  TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;  TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;  int lc &#x3D; 0, hc &#x3D; 0;  &#x2F;&#x2F;将一颗红黑树变为两张链表  for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;    next &#x3D; (TreeNode&lt;K,V&gt;)e.next;    e.next &#x3D; null;    &#x2F;&#x2F;如果hash与oldCap做与运算结果为0，则说明元素所处的数组位置不用改变。    if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;      if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)        loHead &#x3D; e;      else        loTail.next &#x3D; e;      loTail &#x3D; e;      ++lc;    &#125;    else &#123;      if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)        hiHead &#x3D; e;      else        hiTail.next &#x3D; e;      hiTail &#x3D; e;      ++hc;    &#125;  &#125;  if (loHead !&#x3D; null) &#123;    &#x2F;&#x2F;判断是否需要将红黑树转换为链表    if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index] &#x3D; loHead.untreeify(map);    else &#123;      tab[index] &#x3D; loHead;      if (hiHead !&#x3D; null)        loHead.treeify(tab);    &#125;  &#125;  if (hiHead !&#x3D; null) &#123;    &#x2F;&#x2F;同上    if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)      tab[index + bit] &#x3D; hiHead.untreeify(map);    else &#123;      tab[index + bit] &#x3D; hiHead;      if (loHead !&#x3D; null)        hiHead.treeify(tab);      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>split的逻辑为</p><ol><li>根据头节点取红黑树中的每个每个节点，并根据每个节点的hash值判断处于新数组的哪个位置，处于相同位置的节点构造为一个链表</li><li>每个红黑树迁移后最多变为两张链表，再根据链表中节点个数是否小于等于6来判断两张链表最终会变成链表还是红黑树</li></ol><p>在putVal方法中，构造红黑树调用了treeifyBin方法，其实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;  int n, index; Node&lt;K,V&gt; e;  &#x2F;&#x2F;如果哈希桶数组为空，或者数组长度小于64，先扩容，而不是转化为红黑树  if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)    resize();  else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;    do &#123;      TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);      if (tl &#x3D;&#x3D; null)        hd &#x3D; p;      else &#123;        p.prev &#x3D; tl;        tl.next &#x3D; p;      &#125;      tl &#x3D; p;    &#125; while ((e &#x3D; e.next) !&#x3D; null);    if ((tab[index] &#x3D; hd) !&#x3D; null)      hd.treeify(tab);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>treeifyBin方法中首先判断数组是否为空，如果不为空再判断数组长度是否小于64，如果小于64，则调用resize方法进行扩容（resize方法处理链表时并没有将链表转化为红黑树，因此在极端情况下，扩容后链表的元素如果还在数组同一个位置，则会出现元素个数超过8的链表）；如果大于等于64，再将链表转为红黑树</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>获取元素使用的是get方法，实现如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V get(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际是根据getNode方法来获取元素的</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;  &#x2F;&#x2F;先根据hash算出所在数组下标，然后遍历链表（红黑树）寻找hashCode等于key并且equals方法也为true的元素，如果有的话则返回，没有的话则返回null  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;    if (first.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      return first;    if ((e &#x3D; first.next) !&#x3D; null) &#123;      if (first instanceof TreeNode)          return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);      do &#123;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;          ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))          return e;      &#125; while ((e &#x3D; e.next) !&#x3D; null);    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>get方法先根据hash值判断要寻找数组中哪个位置，然后遍历链表（或红黑树），找到key相等并且equals为true的节点，返回其value值；如果找不到，则返回null</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>  移除元素使用的是remove方法，实现如下:</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V remove(Object key) &#123;  Node&lt;K,V&gt; e;  return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?      null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  实际调用的是removeNode方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                         boolean matchValue, boolean movable) &#123;  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;  &#x2F;&#x2F;先查找元素  if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;    (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;    Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;    if (p.hash &#x3D;&#x3D; hash &amp;&amp;      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))      node &#x3D; p;    else if ((e &#x3D; p.next) !&#x3D; null) &#123;      if (p instanceof TreeNode)        node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);      else &#123;        do &#123;          if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key ||             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;            node &#x3D; e;            break;          &#125;          p &#x3D; e;        &#125; while ((e &#x3D; e.next) !&#x3D; null);      &#125;    &#125;    &#x2F;&#x2F;如果存在的话则删除    if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||(value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;      if (node instanceof TreeNode)        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);      else if (node &#x3D;&#x3D; p)        tab[index] &#x3D; node.next;      else        p.next &#x3D; node.next;      ++modCount;      --size;      &#x2F;&#x2F;这里是个空实现，主要是为了删除元素后LinkedHashMap对双向链表进行删除      afterNodeRemoval(node);      return node;    &#125;  &#125;  return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>removeNode方法与get方法获取元素的方式一致，如果找到了对应的key则删除。这里值得注意的一点是树节点的删除，调用了removeTreeNode方法，里面对于红黑树退化成链表的判断逻辑如下</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是remove可能会导致出现只要4个节点的红黑树</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>  序列化使用的是writeObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void writeObject(java.io.ObjectOutputStream s)    throws IOException &#123;  int buckets &#x3D; capacity();  &#x2F;&#x2F;写入threshold、loadfactor等属性  s.defaultWriteObject();  &#x2F;&#x2F;写入数组大小  s.writeInt(buckets);  &#x2F;&#x2F;写入元素个数  s.writeInt(size);  &#x2F;&#x2F;写入哈希桶数组中每个元素  internalWriteEntries(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化的时候除了常用的属性写入字节流外，还将每个节点写入了字节流</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>  反序列化使用的是readObject方法</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;  &#x2F;&#x2F;获取threshold，loadfactor等属性  s.defaultReadObject();  &#x2F;&#x2F;初始化必要的属性  reinitialize();  if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))    throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                     loadFactor);  &#x2F;&#x2F;读取写入时的buckets  s.readInt();        &#x2F;&#x2F;读取HashMap中元素的个数            int mappings &#x3D; s.readInt();  if (mappings &lt; 0)    throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +mappings);  else if (mappings &gt; 0) &#123;    &#x2F;&#x2F;根据元素个数确定哈希桶数组大小    float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);    float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;    int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?               DEFAULT_INITIAL_CAPACITY :               (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?               MAXIMUM_CAPACITY :               tableSizeFor((int)fc));    float ft &#x3D; (float)cap * lf;    threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                 (int)ft : Integer.MAX_VALUE);    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];    table &#x3D; tab;    &#x2F;&#x2F;读取每个元素，并调用putVal方法重新构建哈希桶数组    for (int i &#x3D; 0; i &lt; mappings; i++) &#123;      @SuppressWarnings(&quot;unchecked&quot;)      K key &#x3D; (K) s.readObject();      @SuppressWarnings(&quot;unchecked&quot;)      V value &#x3D; (V) s.readObject();      putVal(hash(key), key, value, false, false);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反序列化则是将字节流中的每个元素取出来，再放入到哈希桶数组中</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
